---
tags:
  - reference
  - cpp
---
# 习惯C++

## 1. 视C++为一个语言联邦

C++主要有四种编程范式：
- C：预处理，语句块，指针，这些概念都来源于C；
- 面向对象：继承，封装，多态，虚函数，这部分是面向对象在C++中的具体实现；
- 模版：这是泛型编程的部分；
- STL：这是一个有模板构成的标准库，提供了大量的基础数据结构；

每一种编程范式都有自己的一些约束，灵活选择范式才能够高效的编程。

## 2. 尽量以编译器替换预处理器

`#define`的主要问题，在于它先于编译阶段，将一些有意义的符号替换为了字面量，如果出现错误会非常难以排查，因为这些符号没有进入符号表中。

针对下面几种常用的宏定义情况，可以做出以下改变：
- 定义常量
	```cpp
	#define PI 3.1415
	const float PI = 3.1415;
	
	// 类内常量
	class A
	{
		enum {Num = 5};
		// 如果不允许定义则将定义放到cpp中
		static const int NumTurns = Num;
	}
	```
- 定义函数
	```cpp
	#define MAX(a, b) ((a) > (b) ? (a) : (b))
	
	template<class T>
	inline void max(const T& a, const T& b)
	{
		return a > b ? a : b;
	}
	```

## 3. 尽可能使用const

`const`允许你指定一个语义约束，即这个对象不能改动，编译器会强制实行这项约束。

它常同指针一起出现，当它出现在`*`的左边时，它代表指向的对象是不可变；当它出现在`*`的右边时，代表指针本身不可变。

`const`有如下用法：
- 用到返回值上，降低客户因意外造成的错误；
	```cpp
	class Rational {};
	Rational a, b, c;
	// 如果+返回的不是const对象，下面这个语句就是合法的。
	(a + b) = c;
	```
- 用到类的函数参数中，使得函数可以处理`const`对象，两个函数如果参数仅是`const`不同，也会构成重载；
- 如果`const`和非`const`有着等价的实现时，可以用非`const`版本来调用`const`版本来避免重复；

## 4. 确认对象使用前已被初始化

为了在使用一个变量时不导致意料之外的结果，一定要在定义变量的时候初始化它们。
- 对内置类型手工初始化，因为c++不保证初始化它们。
- 构造函数最好使用成员初值列表，而不要在构造函数内使用赋值操作，因为初值列表会更加高效。初值列表中初始化的顺序在编译器的控制下同类中声明的顺序一致，和你书写的顺序无关，为了避免混淆，尽量保持它们顺序一致。
	```cpp
	class C {};
	C::C(string name, int age):
		theName(name), //这里初始化叫做初值列表
		theAge(age)
	{
		// 这里执行的是赋值操作
	}
	```
- 对于非局部的静态变量，不要直接使用，而是使用返回静态变量引用的函数，因为编译器保证函数内的局部静态变量在使用它前一定会被初始化。
	```cpp
	FileSystem& GetFS()
	{
		static FileSystem fs;
		return fs;
	}
	```

> [!hint]
> 注意：初值列表尽量将全部成员都包含其中，哪怕有的会自动初始化，但这样可以避免遗漏。

# 构造/析构/赋值

## 5.了解C++默默编写的函数

当你声明一个空类时，编译器会为你生成以下函数：
```cpp
class A
{
public:
	// A a 默认构造函数
	Empty() {}
	// b = A(a) 拷贝构造函数
	Empty(const Empty& rhs) {}
	// 析构函数，注意是非虚的
	~Empty() {}
	// b = a 赋值构造函数
	Empty& operator=(const Empty& rhs) {}
}
```

如果你自己定义了相应的版本，那么编译器就不会为你生成对应的函数，比如你定义了一个任意形式的构造函数，那么默认构造函数不会再生成。

> [!hint]
> 另外如果类内部的变量含有`const`，引用，而拷贝对这两种类型是没法进行复制的，所以此时也不会生成拷贝和赋值构造函数。

## 6. 若不想使用编译器自动生成的函数，则明确拒绝

如果某个对象不应该有复制品，那么它就不应该支持赋值和拷贝操作，做法为：
- 将这两个构造函数声明为`private`并且不定义，这样外部就无法复制了，即便有友元对象，也会在链接阶段报错；
	```cpp
	class A
	{
	private:
		A(const A&);
		A& operator=(const A&);
	};
	```
- 创建一个基类，其内部实现禁止复制的逻辑，然后你的类来继承它。这样做的好处是，友元对象的调用报错会提前到编译期；
	```cpp
	class Uncopyable
	{
	protected:
		Uncopyable() {}
		~Uncopyable() {}
	private:
		Uncopyable(const Uncopyable&);
		Uncopyable& operator=(const Uncopyable&);
	};
	
	class A : private Uncopyable {};
	```

> [!hint]
> 无论是编译器生成的还是自己定义的析构函数，都会自动调用非静态的成员变量的析构函数。

## 7. 为多态基类声明virtual析构函数

如果一个基类的析构函数不是虚的，当使用基类指针指向一个子类对象，并进行释放时，只会释放基类的空间，而对子类空间的行为是未定义的，这很有可能造成内存泄漏，所以当基类有多态的用法时，析构函数必须是虚的。

但如果类本身不需要被继承，或者说不以多态的方式使用，那么最好不要加虚析构函数，因为这会导致类对象变大，多出一个地方存放*虚表指针*。

> [!hint]
> 如果想要声明一个抽象类，但内部没有函数，那么可以把析构函数声明为纯虚，但要给析构函数一个实现，否则链接器会报错。

## 8. 别让异常逃离析构函数

想象一个场景：
```cpp
class A {}
void func()
{
	vector<A> b;
	// 当离开时销毁b内的全部元素
}
```

如果销毁第一个A时析构函数抛出异常，那么后面的元素很可能就没有办法处理了，这就导致了内存泄漏。

所以一定要在析构函数中捕获异常，但也要给客户提供一个主动处理异常的机会：
```cpp
class A
{
public:
	void close()
	{
		// 主动释放资源，可能抛出异常
		is_closed = true;
	}
	virtual ~A()
	{
		if (!is_closed)
		{
			try
			{
				close();
			}
			catch (...)
			{
				// 记录异常
			}
		}
	}
private:
	bool is_closed;
};
```

## 9. 绝对不要在构造/析构函数中调用虚方法

当构造一个派生类对象时，会优先构造它的基类对象，如果此时调用虚方法，调用的实际上是基类里的虚方法。这是因为派生类对象内部数据还没有初始化，所以调用它的虚方法明显是一个未定义的行为。析构函数也是同理，析构会优先派生对象，所以如果调用属于它的虚函数，也是未定义的行为。

## 10. 令operator=返回一个this引用

内置类型的复制可以写成：
```cpp
int x, y, z;
x = y = z = 10;
```

所以如果想要让你的对象表现出和内置对象类似的行为，应该让所有的赋值类操作符号都这样实现：
```cpp
class A
{
	A& operator=(const A& rhs)
	{
		// some code
		return *this;
	}
	A& operator=(int);
	A& operator+=(const A& rhs);
}
```

注意：这是一个约定，而不是强制的行为。

## 11. 在赋值操作符中处理自我赋值

如果赋值操作包含一些资源释放，或者可能导致异常的操作，那么合理的安排赋值的代码是非常有必要的，否则可能导致悬挂指针和内存泄漏等问题。

```cpp
A& A::operator=(const A& rhs)
{
	// 这个语句如果不会出现自我赋值的情况可以不加，因为这种测试会导致执行速度变慢
	if (this == &rhs) return *this;

	File* org = file_ptr;
	file_ptr = new File(*rhs.file_ptr);
	delete org;
	return *this;
}
```

以上代码的核心在于：
- 确保自我赋值不会悬挂指针等问题；
- 即便出现异常也不会破坏对象；

## 12. 赋值对象时勿忘每一个成分

如果你自己实现了两个拷贝相关的构造函数，那么编译器就不会再为你生成，并且即便你遗漏了某些变量的复制，也不会做出任何警告，所以要注意两点：
- 拷贝时确保复制每一个成员和所有的基类成分；
```cpp
class A : B
{
	A(const A& rhs)
	: B(rhs), a(rhs.a)
	{
	}
private:
	int a;
}
```
- 不要尝试以拷贝构造函数调用赋值构造函数，或者反之，而是应该用提供一个私有函数，让它们来调用之。

# 资源管理

## 13. 以对象管理资源

手动调用`delete`来释放资源永远不是一个好的选择，因为随着维护，更新，有很多种可能导致你的`delete`语句调用不到，所以就要利用C++提供的[[C++#RAII 是什么|RAII]]机制，将资源处于对象的控制中，当其离开作用于就会调用析构函数自动释放。

通过智能指针`shared_ptr`，可以实现对运行时创建对象的资源管理。

```cpp
void Func()
{
	shared_ptr<Resource> ptr(new Resource());
	// 当离开作用域后会自动释放管理的资源
}
```

## 14. 在资源管理类中小心copy行为

复制对象时必须一并复制其所管理的资源，一般有如下的解决方式：
- 禁止复制对象，使用[[Effective C++#6. 若不想使用编译器自动生成的函数，则明确拒绝|禁止复制]]；
- 使用`shared_ptr`管理资源，允许多个对象共享同一份资源；
- 进行深层复制，不同的对象持有不同的资源；
- 转移所有权，使用`unique_ptr`；

## 15. 在资源管理类中提供对原始资源的访问

总有一些接口需要直接使用原始资源，而不是负责管理它生命周期的对象，所以你的资源管理类中必须要提供能够访问原始资源的接口，比如智能指针就提供了这样的接口：

```cpp
shared_ptr<Resource> p(new Resource());
// 这个函数返回Resource类型的资源
p.get();
```

你也可以定义隐式转换操作符号，用起来会更方便：

```cpp
class Mgr
{
	operator Resource() const
	{
		return res;
	}
};
```

但是要注意隐式转换可能会被误用，所以尽量还是使用显式转换。

## 16. 成对使用new和delete要采取相同的形式

当你new一个数组和一个对象时，它们的内存结构是完全不一样的：

![[Effective C++ 2024-08-18 13.11.30.excalidraw]]

即new一个数组会有一个位置保存数组的大小，以便在析构时将全部的元素析构。所以当new和delete不匹配时，一定会造成未定义的行为。

所以如果new的是对象，那么delete也是对象，如果`new []`，那么释放时也要`delete []`；

## 17. 以独立语句将newed对象置入智能指针

使用智能指针管理对象时，一定要用单独的语句来初始化它，参考如下情况：

```cpp
func(shared_ptr<Resource>(new Resource()), foo());
```

其中：
1. 初始化Resource；
2. 调用foo();
3. 初始化shared_ptr;
只能保证1在3前，而2可能在任意位置，比如1，2，3的顺序。如果出现这种情况，并且foo()内部抛出了异常，那么此时就发生了内存泄漏。

# 设计与声明

## 18. 让接口易被正确使用

好的接口容易被正确使用，不容易被误用，尽量让所有的接口达成这些性质。

常见的约定包括：
- 保持与内置类型的行为的一致性，比如你实现的类型是一个容器，那么支持`size()`就是一个非常合理的行为，因为内置类型都是如此。
- 阻止客户误用。
	- 类型约束，比如用月份类型替代1-12的数字，因为月份类型可以对输入进行检查。
	- 消除客户的资源管理责任，比如与其返回一个资源对象，不如直接返回一个管理资源的智能指针。
	- 限制类型操作，比如如果不想让对象改变返回值，那么就在返回值上施加`const`。

## 19. 设计class犹如设计type

一个完美的class就应该同语言内置的type一样，有着自然的语法，直观的语义。因此你应该带着同“语言设计者设计内置类型”一样的心态来设计class。

在设计时考虑如下因素：
- 你真的需要一个类型吗？有没有更简洁，更好的方案？
- 新类型应该如何创建和销毁？这影响到析构和构造函数。
- 对象的初始化和赋值有什么区别？这影响到赋值构造函数。
- 对象如果以值传递，意味着什么？这影响到拷贝构造函数。
- 什么是这个类型的合法值？
- 你的类型需要配合某套继承结构吗？
- 你的类型需要进行什么样的转型？
- 那些操作和操作符对这个对象是合理的？
- 你的类型有多么一般化？是否应该采用模板技术？

## 20. 宁以传常量引用替换传值

传值是缺省状态下函数的参数传递模式，但大部分时候传常量引用的速度都要大于传值。
- 如果对象是个自定义类型，传值会涉及到大量的构造和析构函数的调用。
- 如果对象是个派生类，函数形参为基类，这导致类型切割问题（因为多态只对引用和指针生效）。
	```cpp
	void func(Base w) {}
	Derived d;
	func(d); // 这会导致派生类在函数内部变为基类。
	```
- 当对象是内置类型时，采用传值会比较高效，因为编译器会优化，直接将值复制到函数中，省去了寻址。
- 当对象是STL的迭代器对象时，因为迭代器是一个临时对象，随意理所当然的应该用值而不是引用。

## 21. 必须返回对象时，不要返回引用

很多时候你想返回一个引用值，只是因为你想避免一次析构，构造的过程，但很多时候这种损耗是无法避免的，因为如果你引用了一个局部变量，当离开作用域后这个引用就会立即陷入未定义的场景。

返回指针也是不可取的，因为你不能要求客户来为所有的返回值进行`delete`。

```cpp
int* func(int x)
{
	return new int(x);
}

// 毫无疑问，这种情况下内存泄漏了。
int a = func(3) * func(4);
```

## 22. 将成员变量声明为private

封装远比你想象的更重要，封装的越彻底，可供改变的余地越大。当一个变量是public时，这意味着可能到处都在使用它，所以你无法修改它；当它是private时，只有类内部和友元在使用，所以你可以随便修改它。而protected实际和public是一样的，还是可能导致大量的子类依赖它从而无法修改。

所以其实只有两种访问权限：private提供封装，和其他的不提供封装。

## 23. 使用非成员函数替代成员函数

考虑下面这个场景：

```cpp
class WebBrowser
{
	void func1();
	void func2();
	void func3();
};
```

如果想要想要调用上述类的全部接口，集成到一个方法中，哪种做法更好呢？
1. 新增一个成员函数。
2. 新增一个非成员非友元函数。

从封装的角度上来说，当private成员被越少的函数使用，那么它的封装性就越好，所以方案2更好，因为它无法访问到类内部的私有变量。

方案2还有个好处，就是这个函数可以声明到其他头文件中，这样客户就可以按需使用，降低了编译的复杂度。

## 24. 若所有参数皆需类型转换，请使用非成员函数

如果你需要为某个函数的所有参数（包括this指针这个隐喻参数）都执行隐式类型转换，那么这个函数必须为非成员函数。

这是因为隐式参数转换只能发生在对象位于函数的参数列表中。而this很明显不在其中。

比如：
```cpp
class Rational
{
public:
	Rational(int numer=0, int denom=1);

	// 这种实现只有Rational * 3这种形式才合法，一旦反过来就无效了。
	const Rational operator*(const Rational& rhs);
}

const Rational operator*(const Rational& lhs,
						 const Rational& rhs)
 {
	 return Rational();
 }
```

只有上述这种实现可以支持任意次序的有理数和整数相乘，因为它支持所有的参数进行隐式转型。

## 25. 实现一个不抛出异常的swap函数

当你的类型存在[[桥接模式]]这种实现手法，相比于直接复制，交换指针可能更为高效，此时就需要重新实现swap函数。

1. 当std::swap对你的类型效率不高时，提供一个swap成员函数，确保其不抛出异常。
2. 然后提供一个非成员的swap用来调用类中的成员函数。
3. 如果这个类型不是模板类，那么在std空间特化它。
	```cpp
	namespace std 
	{
		template<>
		void swap<A>(A& a, A& b)
		{
			a.swap(b);
		}
	}
	```

# 实现

## 26. 尽可能延后变量定义式的出现时间

# 继承与面向对象