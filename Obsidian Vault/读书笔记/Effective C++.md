---
tags:
  - reference
  - cpp
---
# 习惯C++

## 1. 视C++为一个语言联邦

C++主要有四种编程范式：
- C：预处理，语句块，指针，这些概念都来源于C；
- 面向对象：继承，封装，多态，虚函数，这部分是面向对象在C++中的具体实现；
- 模版：这是泛型编程的部分；
- STL：这是一个有模板构成的标准库，提供了大量的基础数据结构；

每一种编程范式都有自己的一些约束，灵活选择范式才能够高效的编程。

## 2. 尽量以编译器替换预处理器

`#define`的主要问题，在于它先于编译阶段，将一些有意义的符号替换为了字面量，如果出现错误会非常难以排查，因为这些符号没有进入符号表中。

针对下面几种常用的宏定义情况，可以做出以下改变：
- 定义常量
	```cpp
	#define PI 3.1415
	const float PI = 3.1415;
	
	// 类内常量
	class A
	{
		enum {Num = 5};
		// 如果不允许定义则将定义放到cpp中
		static const int NumTurns = Num;
	}
	```
- 定义函数
	```cpp
	#define MAX(a, b) ((a) > (b) ? (a) : (b))
	
	template<class T>
	inline void max(const T& a, const T& b)
	{
		return a > b ? a : b;
	}
	```

## 3. 尽可能使用const

`const`允许你指定一个语义约束，即这个对象不能改动，编译器会强制实行这项约束。

它常同指针一起出现，当它出现在`*`的左边时，它代表指向的对象是不可变；当它出现在`*`的右边时，代表指针本身不可变。

`const`有如下用法：
- 用到返回值上，降低客户因意外造成的错误；
	```cpp
	class Rational {};
	Rational a, b, c;
	// 如果+返回的不是const对象，下面这个语句就是合法的。
	(a + b) = c;
	```
- 用到类的函数参数中，使得函数可以处理`const`对象，两个函数如果参数仅是`const`不同，也会构成重载；
- 如果`const`和非`const`有着等价的实现时，可以用非`const`版本来调用`const`版本来避免重复；

## 4. 确认对象使用前已被初始化

为了在使用一个变量时不导致意料之外的结果，一定要在定义变量的时候初始化它们。
- 对内置类型手工初始化，因为c++不保证初始化它们。
- 构造函数最好使用成员初值列表，而不要在构造函数内使用赋值操作，因为初值列表会更加高效。初值列表中初始化的顺序在编译器的控制下同类中声明的顺序一致，和你书写的顺序无关，为了避免混淆，尽量保持它们顺序一致。
	```cpp
	class C {};
	C::C(string name, int age):
		theName(name), //这里初始化叫做初值列表
		theAge(age)
	{
		// 这里执行的是赋值操作
	}
	```
- 对于非局部的静态变量，不要直接使用，而是使用返回静态变量引用的函数，因为编译器保证函数内的局部静态变量在使用它前一定会被初始化。
	```cpp
	FileSystem& GetFS()
	{
		static FileSystem fs;
		return fs;
	}
	```

> [!hint]
> 注意：初值列表尽量将全部成员都包含其中，哪怕有的会自动初始化，但这样可以避免遗漏。

# 构造/析构/赋值

## 5.了解C++默默编写的函数

当你声明一个空类时，编译器会为你生成以下函数：
```cpp
class A
{
public:
	// A a 默认构造函数
	Empty() {}
	// b = A(a) 拷贝构造函数
	Empty(const Empty& rhs) {}
	// 析构函数，注意是非虚的
	~Empty() {}
	// b = a 赋值构造函数
	Empty& operator=(const Empty& rhs) {}
}
```

如果你自己定义了相应的版本，那么编译器就不会为你生成对应的函数，比如你定义了一个任意形式的构造函数，那么默认构造函数不会再生成。

> [!hint]
> 另外如果类内部的变量含有`const`，引用，而拷贝对这两种类型是没法进行复制的，所以此时也不会生成拷贝和赋值构造函数。

## 6. 若不想使用编译器自动生成的函数，则明确拒绝

如果某个对象不应该有复制品，那么它就不应该支持赋值和拷贝操作，做法为：
- 将这两个构造函数声明为`private`并且不定义，这样外部就无法复制了，即便有友元对象，也会在链接阶段报错；
	```cpp
	class A
	{
	private:
		A(const A&);
		A& operator=(const A&);
	};
	```
- 创建一个基类，其内部实现禁止复制的逻辑，然后你的类来继承它。这样做的好处是，友元对象的调用报错会提前到编译期；
	```cpp
	class Uncopyable
	{
	protected:
		Uncopyable() {}
		~Uncopyable() {}
	private:
		Uncopyable(const Uncopyable&);
		Uncopyable& operator=(const Uncopyable&);
	};
	
	class A : private Uncopyable {};
	```

## 7. 为多态基类声明virtual析构函数

如果一个基类的析构函数不是虚的，当使用基类指针指向一个子类对象，并进行释放时，只会释放基类的空间，而对子类空间的行为是未定义的，这很有可能造成内存泄漏，所以当基类有多态的用法时，析构函数必须是虚的。

但如果类本身不需要被继承，或者说不以多态的方式使用，那么最好不要加虚析构函数，因为这会导致类对象变大，多出一个地方存放*虚表指针*。

> [!hint]
> 如果想要声明一个抽象类，但内部没有函数，那么可以把析构函数声明为纯虚，但要给析构函数一个实现，否则链接器会报错。

## 8. 别让异常逃离析构函数

想象一个场景：
```cpp
class A {}
void func()
{
	vector<A> b;
	// 当离开时销毁b内的全部元素
}
```

如果销毁第一个A时析构函数抛出异常，那么后面的元素很可能就没有办法处理了，这就导致了内存泄漏。

所以一定要在析构函数中捕获异常，但也要给客户提供一个主动处理异常的机会：
```cpp
class A
{
public:
	void close()
	{
		// 主动释放资源，可能抛出异常
		is_closed = true;
	}
	virtual ~A()
	{
		if (!is_closed)
		{
			try
			{
				close();
			}
			catch (...)
			{
				// 记录异常
			}
		}
	}
private:
	bool is_closed;
};
```

## 9. 绝对不要在构造/析构函数中调用虚方法

当构造一个派生类对象时，会优先构造它的基类对象，如果此时调用虚方法，调用的实际上是基类里的虚方法。这是因为派生类对象内部数据还没有初始化，所以调用它的虚方法明显是一个未定义的行为。析构函数也是同理，析构会优先派生对象，所以如果调用属于它的虚函数，也是未定义的行为。

## 10. 令operator=返回一个this引用

内置类型的复制可以写成：
```cpp
int x, y, z;
x = y = z = 10;
```

所以如果想要让你的对象表现出和内置对象类似的行为，应该让所有的赋值类操作符号都这样实现：
```cpp
class A
{
	A& operator=(const A& rhs)
	{
		// some code
		return *this;
	}
	A& operator=(int);
	A& operator+=(const A& rhs);
}
```

注意：这是一个约定，而不是强制的行为。