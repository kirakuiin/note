---
tags:
  - reference
  - cpp
---
# 习惯C++

## 1. 视C++为一个语言联邦

C++主要有四种编程范式：
- C：预处理，语句块，指针，这些概念都来源于C；
- 面向对象：继承，封装，多态，虚函数，这部分是面向对象在C++中的具体实现；
- 模版：这是泛型编程的部分；
- STL：这是一个有模板构成的标准库，提供了大量的基础数据结构；

每一种编程范式都有自己的一些约束，灵活选择范式才能够高效的编程。

## 2. 尽量以编译器替换预处理器

`#define`的主要问题，在于它先于编译阶段，将一些有意义的符号替换为了字面量，如果出现错误会非常难以排查，因为这些符号没有进入符号表中。

针对下面几种常用的宏定义情况，可以做出以下改变：
- 定义常量
	```cpp
	#define PI 3.1415
	const float PI = 3.1415;
	
	// 类内常量
	class A
	{
		enum {Num = 5};
		// 如果不允许定义则将定义放到cpp中
		static const int NumTurns = Num;
	}
	```
- 定义函数
	```cpp
	#define MAX(a, b) ((a) > (b) ? (a) : (b))
	
	template<class T>
	inline void max(const T& a, const T& b)
	{
		return a > b ? a : b;
	}
	```

## 3. 尽可能使用const

`const`允许你指定一个语义约束，即这个对象不能改动，编译器会强制实行这项约束。

它常同指针一起出现，当它出现在`*`的左边时，它代表指向的对象是不可变；当它出现在`*`的右边时，代表指针本身不可变。

`const`有如下用法：
- 用到返回值上，降低客户因意外造成的错误；
	```cpp
	class Rational {};
	Rational a, b, c;
	// 如果+返回的不是const对象，下面这个语句就是合法的。
	(a + b) = c;
	```
- 用到类的函数参数中，使得函数可以处理`const`对象，两个函数如果参数仅是`const`不同，也会构成重载；
- 用到成员函数的名字后面，代表这个成员函数不会修改类内部状态。
- 如果`const`和非`const`有着等价的实现时，可以用非`const`版本来调用`const`版本来避免重复；

## 4. 确认对象使用前已被初始化

为了在使用一个变量时不导致意料之外的结果，一定要在定义变量的时候初始化它们。
- 对内置类型手工初始化，因为c++不保证初始化它们。
- 构造函数最好使用成员初值列表，而不要在构造函数内使用赋值操作，因为初值列表会更加高效。初值列表中初始化的顺序在编译器的控制下同类中声明的顺序一致，和你书写的顺序无关，为了避免混淆，尽量保持它们顺序一致。
	```cpp
	class C {};
	C::C(string name, int age):
		theName(name), //这里初始化叫做初值列表
		theAge(age)
	{
		// 这里执行的是赋值操作
	}
	```
- 对于非局部的静态变量，不要直接使用，而是使用返回静态变量引用的函数，因为编译器保证函数内的局部静态变量在使用它前一定会被初始化。
	```cpp
	FileSystem& GetFS()
	{
		static FileSystem fs;
		return fs;
	}
	```

> [!hint]
> 注意：初值列表尽量将全部成员都包含其中，哪怕有的会自动初始化，但这样可以避免遗漏。

# 构造/析构/赋值

## 5.了解C++默默编写的函数

当你声明一个空类时，编译器会为你生成以下函数：
```cpp
class A
{
public:
	// A a 默认构造函数
	Empty() {}
	// b = A(a) 拷贝构造函数
	Empty(const Empty& rhs) {}
	// 析构函数，注意是非虚的
	~Empty() {}
	// b = a 赋值构造函数
	Empty& operator=(const Empty& rhs) {}
}
```

如果你自己定义了相应的版本，那么编译器就不会为你生成对应的函数，比如你定义了一个任意形式的构造函数，那么默认构造函数不会再生成。

> [!hint]
> 另外如果类内部的变量含有`const`，引用，而拷贝对这两种类型是没法进行复制的，所以此时也不会生成拷贝和赋值构造函数。

## 6. 若不想使用编译器自动生成的函数，则明确拒绝

如果某个对象不应该有复制品，那么它就不应该支持赋值和拷贝操作，做法为：
- 将这两个构造函数声明为`private`并且不定义，这样外部就无法复制了，即便有友元对象，也会在链接阶段报错；
	```cpp
	class A
	{
	private:
		A(const A&);
		A& operator=(const A&);
	};
	```
- 创建一个基类，其内部实现禁止复制的逻辑，然后你的类来继承它。这样做的好处是，友元对象的调用报错会提前到编译期；
	```cpp
	class Uncopyable
	{
	protected:
		Uncopyable() {}
		~Uncopyable() {}
	private:
		Uncopyable(const Uncopyable&);
		Uncopyable& operator=(const Uncopyable&);
	};
	
	class A : private Uncopyable {};
	```

> [!hint]
> 无论是编译器生成的还是自己定义的析构函数，都会自动调用非静态的成员变量的析构函数。

## 7. 为多态基类声明virtual析构函数

如果一个基类的析构函数不是虚的，当使用基类指针指向一个子类对象，并进行释放时，只会释放基类的空间，而对子类空间的行为是未定义的，这很有可能造成内存泄漏，所以当基类有多态的用法时，析构函数必须是虚的。

但如果类本身不需要被继承，或者说不以多态的方式使用，那么最好不要加虚析构函数，因为这会导致类对象变大，多出一个地方存放*虚表指针*。

> [!hint]
> 如果想要声明一个抽象类，但内部没有函数，那么可以把析构函数声明为纯虚，但要给析构函数一个实现，否则链接器会报错。

## 8. 别让异常逃离析构函数

想象一个场景：
```cpp
class A {}
void func()
{
	vector<A> b;
	// 当离开时销毁b内的全部元素
}
```

如果销毁第一个A时析构函数抛出异常，那么后面的元素很可能就没有办法处理了，这就导致了内存泄漏。

所以一定要在析构函数中捕获异常，但也要给客户提供一个主动处理异常的机会：
```cpp
class A
{
public:
	void close()
	{
		// 主动释放资源，可能抛出异常
		is_closed = true;
	}
	virtual ~A()
	{
		if (!is_closed)
		{
			try
			{
				close();
			}
			catch (...)
			{
				// 记录异常
			}
		}
	}
private:
	bool is_closed;
};
```

## 9. 绝对不要在构造/析构函数中调用虚方法

当构造一个派生类对象时，会优先构造它的基类对象，如果此时调用虚方法，调用的实际上是基类里的虚方法。这是因为派生类对象内部数据还没有初始化，所以调用它的虚方法明显是一个未定义的行为。析构函数也是同理，析构会优先释放派生对象，所以如果调用属于它的虚函数，也是未定义的行为。

## 10. 令operator=返回一个this引用

内置类型的复制可以写成：
```cpp
int x, y, z;
x = y = z = 10;
```

所以如果想要让你的对象表现出和内置对象类似的行为，应该让所有的赋值类操作符号都这样实现：
```cpp
class A
{
	A& operator=(const A& rhs)
	{
		// some code
		return *this;
	}
	A& operator=(int);
	A& operator+=(const A& rhs);
}
```

注意：这是一个约定，而不是强制的行为。

## 11. 在赋值操作符中处理自我赋值

如果赋值操作包含一些资源释放，或者可能导致异常的操作，那么合理的安排赋值的代码是非常有必要的，否则可能导致悬挂指针和内存泄漏等问题。

```cpp
A& A::operator=(const A& rhs)
{
	// 这个语句如果不会出现自我赋值的情况可以不加，因为这种测试会导致执行速度变慢
	if (this == &rhs) return *this;

	File* org = file_ptr;
	file_ptr = new File(*rhs.file_ptr);
	delete org;
	return *this;
}
```

以上代码的核心在于：
- 确保自我赋值不会悬挂指针等问题；
- 即便出现异常也不会破坏对象；

## 12. 赋值对象时勿忘每一个成分

如果你自己实现了两个拷贝相关的构造函数，那么编译器就不会再为你生成，并且即便你遗漏了某些变量的复制，也不会做出任何警告，所以要注意两点：
- 拷贝时确保复制每一个成员和所有的基类成分；
```cpp
class A : B
{
	A(const A& rhs)
	: B(rhs), a(rhs.a)
	{
	}
private:
	int a;
}
```
- 不要尝试以拷贝构造函数调用赋值构造函数，或者反之，而是应该用提供一个私有函数，让它们来调用之。

# 资源管理

## 13. 以对象管理资源

手动调用`delete`来释放资源永远不是一个好的选择，因为随着维护，更新，有很多种可能导致你的`delete`语句调用不到，所以就要利用C++提供的[[C++#RAII 是什么|RAII]]机制，将资源处于对象的控制中，当其离开作用于就会调用析构函数自动释放。

通过智能指针`shared_ptr`，可以实现对运行时创建对象的资源管理。

```cpp
void Func()
{
	shared_ptr<Resource> ptr(new Resource());
	// 当离开作用域后会自动释放管理的资源
}
```

## 14. 在资源管理类中小心copy行为

复制对象时必须一并复制其所管理的资源，一般有如下的解决方式：
- 禁止复制对象，使用[[Effective C++#6. 若不想使用编译器自动生成的函数，则明确拒绝|禁止复制]]；
- 使用`shared_ptr`管理资源，允许多个对象共享同一份资源；
- 进行深层复制，不同的对象持有不同的资源；
- 转移所有权，使用`unique_ptr`；

## 15. 在资源管理类中提供对原始资源的访问

总有一些接口需要直接使用原始资源，而不是负责管理它生命周期的对象，所以你的资源管理类中必须要提供能够访问原始资源的接口，比如智能指针就提供了这样的接口：

```cpp
shared_ptr<Resource> p(new Resource());
// 这个函数返回Resource类型的资源
p.get();
```

你也可以定义隐式转换操作符号，用起来会更方便：

```cpp
class Mgr
{
	operator Resource() const
	{
		return res;
	}
};
```

但是要注意隐式转换可能会被误用，所以尽量还是使用显式转换。

## 16. 成对使用new和delete要采取相同的形式

当你new一个数组和一个对象时，它们的内存结构是完全不一样的：

![[Effective C++ 2024-08-18 13.11.30.excalidraw]]

即new一个数组会有一个位置保存数组的大小，以便在析构时将全部的元素析构。所以当new和delete不匹配时，一定会造成未定义的行为。

所以如果new的是对象，那么delete也是对象，如果`new []`，那么释放时也要`delete []`；

## 17. 以独立语句将newed对象置入智能指针

使用智能指针管理对象时，一定要用单独的语句来初始化它，参考如下情况：

```cpp
func(shared_ptr<Resource>(new Resource()), foo());
```

其中：
1. 初始化Resource；
2. 调用foo();
3. 初始化shared_ptr;
只能保证1在3前，而2可能在任意位置，比如1，2，3的顺序。如果出现这种情况，并且foo()内部抛出了异常，那么此时就发生了内存泄漏。

# 设计与声明

## 18. 让接口易被正确使用

好的接口容易被正确使用，不容易被误用，尽量让所有的接口达成这些性质。

常见的约定包括：
- 保持与内置类型的行为的一致性，比如你实现的类型是一个容器，那么支持`size()`就是一个非常合理的行为，因为内置类型都是如此。
- 阻止客户误用。
	- 类型约束，比如用月份类型替代1-12的数字，因为月份类型可以对输入进行检查。
	- 消除客户的资源管理责任，比如与其返回一个资源对象，不如直接返回一个管理资源的智能指针。
	- 限制类型操作，比如如果不想让对象改变返回值，那么就在返回值上施加`const`。

## 19. 设计class犹如设计type

一个完美的class就应该同语言内置的type一样，有着自然的语法，直观的语义。因此你应该带着同“语言设计者设计内置类型”一样的心态来设计class。

在设计时考虑如下因素：
- 你真的需要一个类型吗？有没有更简洁，更好的方案？
- 新类型应该如何创建和销毁？这影响到析构和构造函数。
- 对象的初始化和赋值有什么区别？这影响到赋值构造函数。
- 对象如果以值传递，意味着什么？这影响到拷贝构造函数。
- 什么是这个类型的合法值？
- 你的类型需要配合某套继承结构吗？
- 你的类型需要进行什么样的转型？
- 那些操作和操作符对这个对象是合理的？
- 你的类型有多么一般化？是否应该采用模板技术？

## 20. 宁以传常量引用替换传值

传值是缺省状态下函数的参数传递模式，但大部分时候传常量引用的速度都要大于传值。
- 如果对象是个自定义类型，传值会涉及到大量的构造和析构函数的调用。
- 如果对象是个派生类，函数形参为基类，这导致类型切割问题（因为多态只对引用和指针生效）。
	```cpp
	void func(Base w) {}
	Derived d;
	func(d); // 这会导致派生类在函数内部变为基类。
	```
- 当对象是内置类型时，采用传值会比较高效，因为编译器会优化，直接将值复制到函数中，省去了寻址。
- 当对象是STL的迭代器对象时，因为迭代器是一个临时对象，随意理所当然的应该用值而不是引用。

## 21. 必须返回对象时，不要返回引用

很多时候你想返回一个引用值，只是因为你想避免一次析构，构造的过程，但很多时候这种损耗是无法避免的，因为如果你引用了一个局部变量，当离开作用域后这个引用就会立即陷入未定义的场景。

返回指针也是不可取的，因为你不能要求客户来为所有的返回值进行`delete`。

```cpp
int* func(int x)
{
	return new int(x);
}

// 毫无疑问，这种情况下内存泄漏了。
int a = func(3) * func(4);
```

## 22. 将成员变量声明为private

封装远比你想象的更重要，封装的越彻底，可供改变的余地越大。当一个变量是public时，这意味着可能到处都在使用它，所以你无法修改它；当它是private时，只有类内部和友元在使用，所以你可以随便修改它。而protected实际和public是一样的，还是可能导致大量的子类依赖它从而无法修改。

所以其实只有两种访问权限：private提供封装，和其他的不提供封装。

## 23. 使用非成员函数替代成员函数

考虑下面这个场景：

```cpp
class WebBrowser
{
	void func1();
	void func2();
	void func3();
};
```

如果想要想要调用上述类的全部接口，集成到一个方法中，哪种做法更好呢？
1. 新增一个成员函数。
2. 新增一个非成员非友元函数。

从封装的角度上来说，当private成员被越少的函数使用，那么它的封装性就越好，所以方案2更好，因为它无法访问到类内部的私有变量。

方案2还有个好处，就是这个函数可以声明到其他头文件中，这样客户就可以按需使用，降低了编译的复杂度。

## 24. 若所有参数皆需类型转换，请使用非成员函数

如果你需要为某个函数的所有参数（包括this指针这个隐喻参数）都执行隐式类型转换，那么这个函数必须为非成员函数。

这是因为隐式参数转换只能发生在对象位于函数的参数列表中。而this很明显不在其中。

比如：
```cpp
class Rational
{
public:
	Rational(int numer=0, int denom=1);

	// 这种实现只有Rational * 3这种形式才合法，一旦反过来就无效了。
	const Rational operator*(const Rational& rhs);
}

const Rational operator*(const Rational& lhs,
						 const Rational& rhs)
 {
	 return Rational();
 }
```

只有上述这种实现可以支持任意次序的有理数和整数相乘，因为它支持所有的参数进行隐式转型。

## 25. 实现一个不抛出异常的swap函数

当你的类型存在[[桥接模式]]这种实现手法，相比于直接复制，交换指针可能更为高效，此时就需要重新实现swap函数。

1. 当std::swap对你的类型效率不高时，提供一个swap成员函数，确保其不抛出异常。
2. 然后提供一个非成员的swap用来调用类中的成员函数。
3. 如果这个类型不是模板类，那么在std空间特化它。
	```cpp
	namespace std 
	{
		template<>
		void swap<A>(A& a, A& b)
		{
			a.swap(b);
		}
	}
	```

# 实现

## 26. 尽可能延后变量定义式的出现时间

让变量延后定义，可以增加程序的清晰度并改善效率，因为越晚定义离使用它的位置就越近，同时因为控制流导致的无效构造的概率就越低

对于：
```
A a;
for (int i = 0; i < n; ++i)
{
	a = x;
}
```

如果赋值的成本大于构造加析构的成本，那么就应该将定义放到循环内部。

## 27. 尽量少做转型动作

除了C语言支持的旧式转型，如：
```cpp
(int)a;
int(a);
```

C++支持4种更加明确职责的转型，如果一定要转型的话请使用[[C++#四种强制转换|新式转型]]。

如果可以的话，尽量避免转型，尤其是在注重效率的代码上不要用dynamic_cast，这会涉及到多次字符串比对，很浪费时间。可以以下方式替换：
- 如果你只有基类指针，但想调用调用子类接口，可以考虑将子类接口移动到基类中。
- 如果你有一个基类指针类型的数组，想要调用子类的接口，那么考虑用子类指针数组和基类指针数组分别存放对象。

> [!hint]
> ```cpp
> class A : public B
> {
> 	void func()
> 	{
> 		 // 这种调用方式实际上是创建了一个临时基类对象并调用其接口，对当前对象无影响。
> 		static_cast\<B\>(*this).Sth();
> 		 // 这是正确的调用方式
> 		B::Sth();
> 	}
> };
> ```

## 28. 避免返回handles指向对象内部部分

如果你返回了一个引用，指针，迭代器。而它指向了对象内部的一个私有变量，如果外部修改了这个引用，相当于已经打破了类的封装性。

所以不要返回内部对象的引用，即便返回了一个`const`引用，还是出现[[C++#野指针和悬挂指针|悬挂指针]]的风险。

不过这个不是绝对的，比如`operator[]`本身就是要返回一个容器内部元素的引用，此时返回引用是合理的。

## 29. 为异常安全努力是值得的

异常安全函数可以保证即使出现异常也不会泄露资源，破坏数据。有[[Effective CSharp#48. 优先考虑做出强异常保证]]。同C#一样，尽量做出强异常保证。

强异常保证通常可以通过一种叫做*copy-and-swap*的策略来实现，即先复制一份当前资源，然后对复制的资源修改，等修改完毕后在赋值回去。

> [!hint]
> 一个函数的异常安全保证等于由其所调用的函数中，异常安全保证最弱的那一个。

## 30. 了解inline的里里外外

inline可以理解为编译期文本替换，同define相比，inline更加安全。

inline分为两种类型：
- 显示inline，即在函数声明前面加上inline关键字。
- 隐式inline，即定义在类内部的函数会被编译器认为是inline函数。

inline的缺点同宏替换类似：
- inline的函数不会留下符号，导致调试困难。
- 过度使用会导致二进制大小膨胀，更近一步可能导致缓存命中率降低。

为了避免它的缺点，所以：
- 将inline限制到小型，被频繁调用的函数上。
- 看起来[[Effective C++#5.了解C++默默编写的函数|构造函数]]只有一行，但编译器会将其展开，实际可能很大，所以尽量不要inline。
- 不要因为函数模板出现在头文件，就将它们声明为inline。

> [!hint]
> 要注意的是，inline只是你对编译器的建议，编译器不一定会采用

## 31. 将文件间的编译依存关系降到最低

很多时候你只是修改了头文件中一个私有变量，并没有修改接口，结果却导致整个程序重新编译，链接。这是因为C++没有把将接口从实现中分离做的很好，所以需要程序员自己注意这一点。

可以遵守如下方案来实行接口与实现分离：
- 如果能使用指针和引用，就不要使用对象，因为接口和引用的大小是已知的，而对象的大小必须要看到类的定义才能知道。
- 尽量使用类的声明式而不是定义式。当你**声明**某个函数其中的参数或返回值是某个类型时，你并不需要类型的定义。
	```cpp
	class A; // 声明式
	A func(); // ok，这里不需要定义式
	void func(A) // ok, 这里也不需要
	```
- 为声明式和定义式提供不同的文件。
	```cpp
	// 声明式Afwd.h
	class A
	{
	public:
		void Func();
		int Foo();
	private:
		shared_ptr<AImpl> impl;
	};
	
	// 定义式A.h
	class AImpl
	{
	public:
		void Func();
		int Foo();
	private:
		int a;
		string b;
	};
	
	// -------------------------------
	// 也可以采用抽象类的方案
	class A
	{
	public:
		virtual void Func() const = 0;
		virtual int F() const = 0;
	
		static shared_ptr<A> create();
	};
	```
- 程序库的头文件应该是完全且仅有类的声明式。

# 继承与面向对象

## 32. 确定你的public继承是is-a关系

当你让一个类D公有继承另一个类B，那么说明D一定是一个B，而B不一定是D。所有使用B的地方都可以用D来替换，这个也被称为也是[[什么是面向对象#里氏替换原则|里氏替换原则]]。

要注意不要将现实世界中的概念原封不动的映射到抽象世界中，比如：

```cpp
class Rectangle
{
public:
	// 拉伸自身
	void stretch();
};

class Square : Rectangle
{
}
```

此时当前建模下的正方形就不应该作为长方形的子类（虽然从数学定义上来说，正方形毫无疑问是一个长方形），但在当前的抽象中，长方形拉伸自己还是长方形，但正方形拉伸自己之后就不在是一个正方形了。

所以为了确保*is-a*关系，基类的每一个接口对子类来说都是有效的。

## 33. 避免遮掩继承而来的名称

编译器查找变量时优先从最里层的作用域开始查找，如果找不到就一层一层的向外找，顺序为：
- 局部
- 类内部
- 基类内部
- 命名空间
- 全局

如果在任意一层找到定义，则会停止，不会向下一层继续寻找。所以如果你的子类定义了和基类同名的函数，即便它们参数不同，子类的函数依旧会覆盖基类的函数。

如果你使用了public继承，这种行为一定是错误的。不过如果你想要被遮掩的函数暴露出来，可以使用如下方法：
- using 声明式
	```cpp
	class A {public void func();};
	class B : public A
	{
	public:
		using A::func;  // 通过这句话可以把基类接口暴露出来
		void func(int);
	};
	```
- 转交函数，可以选择性的暴露一部分接口。
	```cpp
	class A {
	public:
		int func(int);
		virtual int func() = 0;
	};
	class B : private A
	{
	public:
		// 只有基类的无参版本暴露出来了。
		int func() override
		{
			return A::func();
		}
	};
	```

## 34. 区分接口继承和实现继承

在public继承的前提下：

- 当基类提供了一个纯虚函数，这代表着希望子类继承它的接口。
- 当基类提供了一个虚函数，这代表着希望子类继承它的接口以及一份默认实现。
- 当基类提供了非虚函数，这代表着希望子类继承这个接口并强制性实现继承。

> [!hint] 纯虚函数的定义
> 纯虚函数也可以拥有定义，可以通过`className::funcName`的形式来调用它，这也可以作为一种默认实现。

## 35. 考虑虚函数以外的选择

当你解决问题而寻找某个设计方法时，也要考虑虚方法的替代方案：
- [[模板方法模式]]：
	```cpp
	class A
	{
	public:
		// 暴露一个非虚接口
		void func()
		{
			// 一些前置工作
	
			// 子类自定义实现的方法
			funcImpl();
	
			// 一些收尾工作
		}
	private:
		virtual void funcImpl();
	};
	```
- 函数指针，将具体的逻辑委托给一个函数，而不是在类内处理。（如果支持的话，使`std::function`是更好的选择。）
	```cpp
	class A
	{
	public:
		typedef void (*Func)();
		void func()
		{
			f();
		}
		explicit A(Func f) : f(f) {}
	private:
		Func f;
	};
	```
- [[策略模式]]，委派另一个对象来处理。

> [!hint]
> 私有虚方法也是可以重写的（如何做），毕竟私有只是禁止你调用（何时）。

## 36. 绝不重新定义继承而来的非虚函数

当你的Dpublic继承一个类B时，也就代表这个类本质上也是个B，那么对于B的非虚接口应该表现出一模一样的行为。如果你为D重新定义了非虚接口，表现出了不一样的行为，那么就会出现以下情况。

```cpp
class B
{
public:
	void f()
	{
		print(1);
	}
};
class D : B
{
public:
	void f()
	{
		print(2);
	}
}

D d;
D& r1 = d;
B& r2 = d;
r1.f(); // 打印2
r2.f(); // 打印1
```

即同一个对象通过类型不同的引用出现了不同的结果，这是因为非虚函数是在编译期静态绑定的，这样的结果很显然是错误的。所以**不要重定义继承而来的非虚函数**。

> [!hint]
> [[Effective C++#7. 为多态基类声明virtual析构函数]]可以视为本条款的特例。

## 37. 绝不重定义继承而来的参数缺省值

这里的主要问题在于，虚函数本身是动态绑定的，而虚函数的参数采用的却是[[C++#静态绑定和动态绑定|静态绑定]]。当你用父类指针指向子类对象，并调用虚函数时，你的函数体使用的是子类的，然而默认的参数确是父类的，这次调用过程变成了子类和父类的混合调用。这明显是错误的。

所以虚函数最好不要有默认参数，有参数还会导致每个子类必须都要加上和父类一样的默认参数，来保证一致性，这大大增加了声明的冗余程度。

可以用[[模板方法模式]]来实现一个替代方案，即非虚接口包含默认参数，然后调用一个虚函数实现其逻辑。

## 38. 通过复合塑模出has-a关系

*has-a*关系，也叫包含，组合。指的是通过把对象组合到一起来实现功能。这种关系在现实世界中也很常见，比如学校含有学生，老师等等，是一种非常直接并且非常强大的概念。

比如你想实现一个底层为链表的集合，那你不应该公有继承链表。因为集合不是一个链表，你应该包含它，通过它来实现这个功能。

```cpp
template<class T>
class Set
{
public:
	bool member(const T& item) const;
	std::size_t size() const;
private:
	std::list<T> impl;
};
```

- 在应用域，也就是对象代表现实世界问题中的某个概念时，*has-a*意味着有一个。
- 在实现域，也就是你的对象是通过什么样的手段实现时，比如缓冲，链表等等，*has-a*意味着“根据某物实现出”。

## 39. 明智而审慎的使用private继承

私有继承在编译器的眼中不被视为一种继承关系，也就是说：

```cpp
class A {};
class B : private A {};

// 错误，B类型不被视为A类型
A* a = new B();
```

所以private继承实际上是一种“根据某物实现出”的关系，类似于组合，但从实践上来说优先使用组合而不是private继承。
- private继承会导致编译依存性增加，而组合不会；
- 当你需要重新定义某个类型中的多个虚函数，并且需要访问其中的成员时，private继承是合理的；
- 当你想要使用**EBO**[^1]时，也需要使用private继承。

## 40. 明智而审慎的使用多重继承

首先多继承会导致歧义，比如两个父类具有同名函数，子类调用时编译器无法决定哪个更好，所以必须手动指明所调用的父类。
```cpp
class A : public B, public C {}
A a;
// 调用B的
a.B::func();
// 调用C的
a.C::func();
```

其次多继承会导致[[C++#棱型继承的问题与解决方案|棱型问题]]。当你考虑用虚继承解决这个问题，要遵循两个准则：
- 非必要不使用虚继承。
- 如果你非要用，尽量让被继承的基类不要含有任何数据。

不过当你碰到这样的场景，public继承某个接口类，private继承某个协助实现的类，此时算是多重继承的正当用途。不过还是那句话，**永远优先考虑单继承而不是多重继承**。

# 模板与范型编程

## 41. 了解隐式接口和编译期多态

模板和类都支持接口和多态。

类的接口是显式的，以函数签名为中心，比如`void func(int)`。多态则是通过虚函数在运行期实现的。

而模板的接口是隐式的，是基于有效表达式的，比如：
```cpp
template <class T>
void func(T& w)
{
	if (w.size() > 10)
	{
		T temp(w);
	}
}
```
此时可以知道T类型的隐式约束，即：
- T必须有拷贝构造函数。
- T必须要返回一个能和整形比较的对象。

而以不同的参数具现化函数模板会导致调用不同的函数，这就是所谓的编译期多态，即编译期的函数重载解析，比如：
```cpp
template <class T>
void func(T& w)
{
	if (w.size() > 10)
	{
	}
}

func<vector>(v1);  // 调用的是vector版的func
func<deque>(d1);  // 调用的是deque版的func
```

## 42. 了解typename的双重意义

对于模板来说，如果：
- template的类型参数：`class`和`typename`作用一样。
	```cpp
	// 以下效果一样
	template <class T>
	template <typename T>
	```
- 当使用模板内的*嵌套从属类型*名称时，前方要加`typename`，不过当这个名称出现在基类列表和成员初始化列表时，不能加`typename`。

嵌套从属名称，指的是：
```cpp
template <class T>
void func()
{
	// 这种T::A就是嵌套从属名称，这个语句是错误的，因为编译器不知道T::A是一个类型还是一个值，所以要显式告诉编译器。
	T::A* x;

	// 正确
	typename T::A* y;
}
```

下面是基类列表和初始化列表的情况。
```cpp
template <class T>
// 不能加typename
class A : public Base<T>::B
{
public:
	// 不能加typename
	A() : Base<T>::B() {}
};
```

## 43. 学习处理模版化类基类的名称

当你在派生模板类中使用基类的成员时，编译器无法确定基类是否真的含有这个成员：
```cpp
class Company
{
public void sendMsg(string& msg);
};

template<class Company>
class MsgSender
{
public:
	void send(string& msg)
	{
		Company c;
		c.sendMsg(msg);
	}
};

template<class Company>
class SpecialSender : public MsgSender<Company>
{
public:
	void sendSpecial(string& msg)
	{
		// 这里无法通过编译
		send(msg);
	}
};
```

出现错误的原因是只有到模板实例化的时候，才知道`Company`是个什么样的参数，而在这个文件的编译期，编译器没法确定父类中是否存在这个函数，所以会报错。

解决方案为：
- 使用`this->`。
	```cpp
	template<class Company>
	class SpecialSender : public MsgSender<Company>
	{
	public:
		void sendSpecial(string& msg)
		{
			// 这次可以了，这将假设这个类会被继承。
			this->send(msg);
		}
	};
	```
- 使用`using`。
	```cpp
	template<class Company>
	class SpecialSender : public MsgSender<Company>
	{
	public:
		using MsgSender<Company>::send
		void sendSpecial(string& msg)
		{
			// 这次可以了，这将假设这个类会被继承。
			send(msg);
		}
	};
	```

## 44. 将参数无关的代码抽离templates

template可能会导致隐式的代码膨胀，比如：
```cpp
template<typename T, size_t n>
class Matrix
{
public:
	void invert();
};

Matrix<double, 5> a;
Matrix<double, 2> b;
```

仅仅是因为参数的些许不同，这将在内存中生成两份相同的代码，这无疑造成了代码膨胀。

所以：
- 任何模板都不应该和造成模板膨胀的参数相关联。
- 因非类型参数造成的膨胀往往可以通过函数参数和函数成员来消除。
- 因类型参数而导致的膨胀，往往可以通过具有完全相同的二进制的具现类型共享来缓解。

## 运用成员函数模板接受所有兼容类型

# 定制 new 和 delete

[^1]: empty base optimization，指当基类不含有任何非静态成员时，继承不会导致类型变大。