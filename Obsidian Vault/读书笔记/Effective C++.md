---
tags:
  - reference
  - cpp
---
# 习惯C++

## 1. 视C++为一个语言联邦

C++主要有四种编程范式：
- C：预处理，语句块，指针，这些概念都来源于C；
- 面向对象：继承，封装，多态，虚函数，这部分是面向对象在C++中的具体实现；
- 模版：这是泛型编程的部分；
- STL：这是一个有模板构成的标准库，提供了大量的基础数据结构；

每一种编程范式都有自己的一些约束，灵活选择范式才能够高效的编程。

## 2. 尽量以编译器替换预处理器

`#define`的主要问题，在于它先于编译阶段，将一些有意义的符号替换为了字面量，如果出现错误会非常难以排查，因为这些符号没有进入符号表中。

针对下面几种常用的宏定义情况，可以做出以下改变：
- 定义常量
	```cpp
	#define PI 3.1415
	const float PI = 3.1415;
	
	// 类内常量
	class A
	{
		enum {Num = 5};
		// 如果不允许定义则将定义放到cpp中
		static const int NumTurns = Num;
	}
	```
- 定义函数
	```cpp
	#define MAX(a, b) ((a) > (b) ? (a) : (b))
	
	template<class T>
	inline void max(const T& a, const T& b)
	{
		return a > b ? a : b;
	}
	```

## 3. 尽可能使用const

`const`允许你指定一个语义约束，即这个对象不能改动，编译器会强制实行这项约束。

它常同指针一起出现，当它出现在`*`的左边时，它代表指向的对象是不可变；当它出现在`*`的右边时，代表指针本身不可变。

`const`有如下用法：
- 用到返回值上，降低客户因意外造成的错误；
	```cpp
	class Rational {};
	Rational a, b, c;
	// 如果+返回的不是const对象，下面这个语句就是合法的。
	(a + b) = c;
	```
- 用到类的函数参数中，使得函数可以处理`const`对象，两个函数如果参数仅是`const`不同，也会构成重载；
- 如果`const`和非`const`有着等价的实现时，可以用非`const`版本来调用`const`版本来避免重复；

## 4. 确认对象使用前已被初始化

为了在使用一个变量时不导致意料之外的结果，一定要在定义变量的时候初始化它们。
- 对内置类型手工初始化，因为c++不保证初始化它们。
- 构造函数最好使用成员初值列表，而不要在构造函数内使用赋值操作，因为初值列表会更加高效。初值列表中初始化的顺序在编译器的控制下同类中声明的顺序一致，和你书写的顺序无关，为了避免混淆，尽量保持它们顺序一致。
	```cpp
	class C {};
	C::C(string name, int age):
		theName(name), //这里初始化叫做初值列表
		theAge(age)
	{
		// 这里执行的是赋值操作
	}
	```
- 对于非局部的静态变量，不要直接使用，而是使用返回静态变量引用的函数，因为编译器保证函数内的局部静态变量在使用它前一定会被初始化。
	```cpp
	FileSystem& GetFS()
	{
		static FileSystem fs;
		return fs;
	}
	```

> [!hint]
> 注意：初值列表尽量将全部成员都包含其中，哪怕有的会自动初始化，但这样可以避免遗漏。

# 构造/析构/赋值

## 5.了解C++默默编写的函数

当你声明一个空类时，编译器会为你生成以下函数：
```cpp
class A
{
public:
	// A a 默认构造函数
	Empty() {}
	// b = A(a) 拷贝构造函数
	Empty(const Empty& rhs) {}
	// 析构函数，注意是非虚的
	~Empty() {}
	// b = a 赋值构造函数
	Empty& operator=(const Empty& rhs) {}
}
```

如果你自己定义了相应的版本，那么编译器就不会为你生成对应的函数，比如你定义了一个任意形式的构造函数，那么默认构造函数不会再生成。

> [!hint]
> 另外如果类内部的变量含有`const`，引用，而拷贝对这两种类型是没法进行复制的，所以此时也不会生成拷贝和赋值构造函数。

## 6. 若不想使用编译器自动生成的函数，则明确拒绝

如果某个对象不应该有复制品，那么它就不应该支持赋值和拷贝操作，做法为：
- 将这两个构造函数声明为`private`并且不定义，这样外部就无法复制了，即便有友元对象，也会在链接阶段报错；
	```cpp
	class A
	{
	private:
		A(const A&);
		A& operator=(const A&);
	};
	```
- 创建一个基类，其内部实现禁止复制的逻辑，然后你的类来继承它。这样做的好处是，友元对象的调用报错会提前到编译期；
	```cpp
	class Uncopyable
	{
	protected:
		Uncopyable() {}
		~Uncopyable() {}
	private:
		Uncopyable(const Uncopyable&);
		Uncopyable& operator=(const Uncopyable&);
	};
	
	class A : private Uncopyable {};
	```

> [!hint]
> 无论是编译器生成的还是自己定义的析构函数，都会自动调用非静态的成员变量的析构函数。

## 7. 为多态基类声明virtual析构函数

如果一个基类的析构函数不是虚的，当使用基类指针指向一个子类对象，并进行释放时，只会释放基类的空间，而对子类空间的行为是未定义的，这很有可能造成内存泄漏，所以当基类有多态的用法时，析构函数必须是虚的。

但如果类本身不需要被继承，或者说不以多态的方式使用，那么最好不要加虚析构函数，因为这会导致类对象变大，多出一个地方存放*虚表指针*。

> [!hint]
> 如果想要声明一个抽象类，但内部没有函数，那么可以把析构函数声明为纯虚，但要给析构函数一个实现，否则链接器会报错。

## 8. 别让异常逃离析构函数

想象一个场景：
```cpp
class A {}
void func()
{
	vector<A> b;
	// 当离开时销毁b内的全部元素
}
```

如果销毁第一个A时析构函数抛出异常，那么后面的元素很可能就没有办法处理了，这就导致了内存泄漏。

所以一定要在析构函数中捕获异常，但也要给客户提供一个主动处理异常的机会：
```cpp
class A
{
public:
	void close()
	{
		// 主动释放资源，可能抛出异常
		is_closed = true;
	}
	virtual ~A()
	{
		if (!is_closed)
		{
			try
			{
				close();
			}
			catch (...)
			{
				// 记录异常
			}
		}
	}
private:
	bool is_closed;
};
```

## 9. 绝对不要在构造/析构函数中调用虚方法

当构造一个派生类对象时，会优先构造它的基类对象，如果此时调用虚方法，调用的实际上是基类里的虚方法。这是因为派生类对象内部数据还没有初始化，所以调用它的虚方法明显是一个未定义的行为。析构函数也是同理，析构会优先派生对象，所以如果调用属于它的虚函数，也是未定义的行为。

## 10. 令operator=返回一个this引用

内置类型的复制可以写成：
```cpp
int x, y, z;
x = y = z = 10;
```

所以如果想要让你的对象表现出和内置对象类似的行为，应该让所有的赋值类操作符号都这样实现：
```cpp
class A
{
	A& operator=(const A& rhs)
	{
		// some code
		return *this;
	}
	A& operator=(int);
	A& operator+=(const A& rhs);
}
```

注意：这是一个约定，而不是强制的行为。

## 11. 在赋值操作符中处理自我赋值

如果赋值操作包含一些资源释放，或者可能导致异常的操作，那么合理的安排赋值的代码是非常有必要的，否则可能导致悬挂指针和内存泄漏等问题。

```cpp
A& A::operator=(const A& rhs)
{
	// 这个语句如果不会出现自我赋值的情况可以不加，因为这种测试会导致执行速度变慢
	if (this == &rhs) return *this;

	File* org = file_ptr;
	file_ptr = new File(*rhs.file_ptr);
	delete org;
	return *this;
}
```

以上代码的核心在于：
- 确保自我赋值不会悬挂指针等问题；
- 即便出现异常也不会破坏对象；

## 12. 赋值对象时勿忘每一个成分

如果你自己实现了两个拷贝相关的构造函数，那么编译器就不会再为你生成，并且即便你遗漏了某些变量的复制，也不会做出任何警告，所以要注意两点：
- 拷贝时确保复制每一个成员和所有的基类成分；
```cpp
class A : B
{
	A(const A& rhs)
	: B(rhs), a(rhs.a)
	{
	}
private:
	int a;
}
```
- 不要尝试以拷贝构造函数调用赋值构造函数，或者反之，而是应该用提供一个私有函数，让它们来调用之。

# 资源管理

## 13. 以对象管理资源

手动调用`delete`来释放资源永远不是一个好的选择，因为随着维护，更新，有很多种可能导致你的`delete`语句调用不到，所以就要利用C++提供的[[C++#RAII 是什么|RAII]]机制，将资源处于对象的控制中，当其离开作用于就会调用析构函数自动释放。

通过智能指针`shared_ptr`，可以实现对运行时创建对象的资源管理。

```cpp
void Func()
{
	shared_ptr<Resource> ptr(new Resource());
	// 当离开作用域后会自动释放管理的资源
}
```

## 14. 在资源管理类中小心copy行为

复制对象时必须一并复制其所管理的资源，一般有如下的解决方式：
- 禁止复制对象，使用[[Effective C++#6. 若不想使用编译器自动生成的函数，则明确拒绝|禁止复制]]；
- 使用`shared_ptr`管理资源，允许多个对象共享同一份资源；
- 进行深层复制，不同的对象持有不同的资源；
- 转移所有权，使用`unique_ptr`；

## 15. 在资源管理类中提供对原始资源的访问

总有一些接口需要直接使用原始资源，而不是负责管理它生命周期的对象，所以你的资源管理类中必须要提供能够访问原始资源的接口，比如智能指针就提供了这样的接口：

```cpp
shared_ptr<Resource> p(new Resource());
// 这个函数返回Resource类型的资源
p.get();
```

你也可以定义隐式转换操作符号，用起来会更方便：

```cpp
class Mgr
{
	operator Resource() const
	{
		return res;
	}
};
```

但是要注意隐式转换可能会被误用，所以尽量还是使用显式转换。

## 16. 成对使用new和delete要采取相同的形式

当你new一个数组和一个对象时，它们的内存结构是完全不一样的：

![[Effective C++ 2024-08-18 13.11.30.excalidraw]]

即new一个数组会有一个位置保存数组的大小，以便在析构时将全部的元素析构。所以当new和delete不匹配时，一定会造成未定义的行为。

所以如果new的是对象，那么delete也是对象，如果`new []`，那么释放时也要`delete []`；

## 17. 以独立语句将newed对象置入智能指针

使用智能指针管理对象时，一定要用单独的语句来初始化它，参考如下情况：

```cpp
func(shared_ptr<Resource>(new Resource()), foo());
```

其中：
1. 初始化Resource；
2. 调用foo();
3. 初始化shared_ptr;
只能保证1在3前，而2可能在任意位置，比如1，2，3的顺序。如果出现这种情况，并且foo()内部抛出了异常，那么此时就发生了内存泄漏。

# 设计与声明

# 实现

# 继承与面向对象