---
tags:
  - methodology
---
# 架构，游戏和性能
 
![[游戏编程模式 2023-10-24 20.52.19.excalidraw]]

从游戏的开发中，有几个重要的观点：

- 在游戏开发期，游戏的灵活性要大于游戏的效能。
> [!note]
 > 游戏的灵活性越大，开发迭代速度越快，游戏便越有趣。 将一个好玩的游戏做的高效总是比将一款高效的游戏做的有趣要简单，所以使用抽象让游戏变得灵活，当其稳定后去除部分抽象提高性能。
  
- 原型开发是完全正确的开发实践
> [!note]
> 快速的开发一个个原型来验证想法，无需考虑原型的代码设计和维护，只需要能运行即可。用完一定要将其丢掉，如果确认使用则仔细设计并重新实现。
> 一个比较良好的习惯是使用另一种语言来开发原型，这样即便你想使用，也必须用游戏语言来重新开发。
	 
 - 保持游戏的简单性
 > [!note]
> 使用一段代码来处理一系列共通的逻辑，事物背后是普遍联系的，找出共性来解决相似的问题而不是使用累加的**if else**。
-  提前优化是万恶之源。
-  如果要做一些有趣的游戏，请乐在其中。

---

# 命令模式

> [!quote]
> 命令就是面向对象化的回调，通过命令将输入和操作解耦。

通过命令模式，我们可以将输入和动作解耦。一个比较经典的应用场景就是**撤销和重做**。

```python
class Command(object):
	def Execute(self):
		pass

	def Undo(self):
		pass

class EditCommand(Command):
	def Execute(self):
		# do something

	def Undo(self):
		# do something

class CopyCommand(Command):
	# ...

# ...
```

使用一个命令栈来存储输入的各种命令，每当undo则将三个指针向前移动，redo则向后移动，如果有新的命令则将cur后面的命令全部丢弃。

![[游戏编程模式 2023-10-24 21.45.33.excalidraw]]

---

> [!note] 与其他模式的联系
> - 如果存在很多命令，可以使用[[游戏编程模式#子类沙盒|子类沙盒]]来在高层提供很多通用函数，在子类命令组合这些函数。
> - 如果对象模型存在分层情况，可以使用[[设计模式#责任链模式|责任链模式]]来将命令转发给附属对象
> - 如果命令是无状态的代码块，可以使用[[游戏编程模式#享元模式|享元模式]]来降低内存使用。
   
# 享元模式

> [!quote]
> 当大量对象内部数据分为两种类型：
>
> - 内部数据(上下文无关)： 这部分数据在所有的对象中都是一致的，和所处的对象没有关系。
> - 外部数据(上下文相关)： 这部分数据代表每个对象自己的特征。
>
> 通过将内部数据存储到一个对象中，大量对象持有内部数据的引用即可有效的减少内存的使用。我们把这些内部对象称为享元(共享的单元)。

使用享元模式的一个经典场景就是构建一个**拥有多种地表纹理的世界**。

```python
class Terrain(object):

	def GetTexture(self):
		"""返回纹理对象"""
		pass


class Water(Terrain):
	"""水体纹理"""


class Forest(Terrain):
	"""森林纹理"""


class World(object):

	def __init__(self):
		self._terrains = []
		self._allTerrainInstance = [Forest(), Water()]

	def Generate(self, worldSize):
		"""生成一个随机世界"""
		self._terrains = [random.choice(self._allTerrainInstance) for i in range(worldSize)]
			
```

假设一个游戏的世界由若干不同地形构成，每种地形都有自己的纹理，因为地形的种类是有限的，但是整个世界的地块确可能存在千千万万，这里便可以应用享元模式。不必为每个地块单独生成自己的地形，而是让若干地块共享一个地形实例。

![[游戏编程模式 2023-10-27 00.41.55.excalidraw]]

---

> [!note] 与其他模式的联系
> -  如果不能预测共有多少享元，那么最好按需创建，可以使用[[设计模式#工厂模式|工厂模式]]管理创建操作。
> -  为了更方便的管理享元，可以使用[[游戏编程模式#对象池|对象池]]来管理。
> - [[游戏编程模式#状态模式|状态模式]]的状态也可以使用享元来表现。

# 观察者模式

> [!quote]
   在对象之间定义一种一对多的关系，以便当某个对象改变时，与他存在依赖关系的所有对象都能收到通知并自动更新。

使用观察者模式的一个经典场景就是**MVC结构[^1]**。

```python
class Observer(object):
	"""观察者"""
	def OnNotify(self):
		"""触发提醒"""
		pass


class Subject(object):
	"""主题"""
	def __init__(self):
		self._allObservers = []

	def Notify(self):
		"""发出提醒"""
		for ob in self._allObservers:
			ob.OnNotify()

	def Register(self, ob):
		"""注册成为观察者"""
		self._allObservers.append(ob)

	def Unregister(self, ob):
		"""取消注册"""
		self._allObservers.remove(ob)


class Model(Subject):
	def SetNewData(self, data):
		# inner operation
		self.Notify()


class Controller(object):
	def __init__(self, model):
		self._model = model
		self._views = [DiagramView(), TableView()]
		for view in self._views:
			model.Register(view)
		
	def AddNewData(self, data):
		self._model.SetNewData(data)


class View(Observer):
	def RefreshView(self):
		"""刷新显示视图"""
		pass

	def OnNotify(self):
		self.RefreshShow()


class DiagramView(View):
	"""图表视图"""
	pass


class TableView(View):
	"""表格视图"""
	pass
```

当数据发生变化时，模型层会发生改变，通过将界面注册为模型层的观察者，使得界面无需和模型耦合。模型层只需要将变化广播出去，而无需关心其他系统如何处理，最终实现了界面和模型同步且独立变化，后续再扩展时只需要注册新的观察者而无需对旧代码进行改动。

![[游戏编程模式 2023-10-25 14.57.07.excalidraw]]

> [!hint]
> - 当一个观察者或被观察者过期时，注意两者的销毁。
> - 观察者适用于处理不相关模块的通信问题，不适用于在单个紧凑的内部模块内通信使用。
> - 目前更流行使用更灵活的观察者方法，比如注册一个观察函数，而不是继承一个类。

# 订阅-发布模式

从[[游戏编程模式#观察者模式|观察者模式]]演化出来的模式，我们发现被观察者内部依然持有观察者的引用，为了彻底的进行解耦，需要新的中间件。这个中间件用来管理全部的订阅，发布。这样观察者和被观察者之间就完成了彻底解耦。

还是使用观察者的例子，代码进行一定调整。

```python
class Slot(object):
	"""中间件"""
	def __init__(self):
		self._allCallbacks = []

	def Notify(self):
		for cb in self._allCallbacks:
			cb()
		
	def Connect(self, callback):
		self._allCallbacks.append(callback)

	def Disconnect(self, callback):
		self._allCallbacks.remove(callback)


ModelSlot = Slot()  # 注册一个全局中间件


class Model(object):
	def SetNewData(self, data):
		# inner operation
		ModelSlot.Notify()


class Controller(object):
	def __init__(self, model):
		self._model = model
		self._views = [DiagramView(), TableView()]

		for view in self._views:
			ModelSlot.Connect(view.RefreshView)
		
	def AddNewData(self, data):
		self._model.SetNewData(data)


class View(object):
	def RefreshView(self):
		"""刷新显示视图"""
		pass


class DiagramView(View):
	"""图表视图"""
	pass


class TableView(View):
	"""表格视图"""
	pass
```

通过这个新的中间件，视图和模型现在完全没有任何联系，后续任何需要得知模型变化的只需要订阅一下中间件就可以了。

![[游戏编程模式 2023-10-25 19.25.52.excalidraw]]

> [!hint]
> - 订阅-发布模式在很多地方都有实现，比如C#的事件，Godot里的信号等等。
# 原型模式

> [!quote]
> 使用特定原型实例来创建特定种类的对象，并且通过拷贝原型来创建新的对象。

使用观察者模式的一个经典场景是**怪兽系统**。

```python
class Monster(object):
	def Clone(self):
		pass


class Slime(Monster):
	def __init__(self, hp, speed):
		self._hp = hp
		self._speed = speed

	def Clone(self):
		return Slime(self._hp, self._speed)
```

无需定义工厂函数，通过clone方法，每个实例可以复制自身，并且同时复制自身的状态。当创建对象消耗较大时（比如说要读取文件），用这个创建怪物对象也会非常迅速。

![[游戏编程模式 2023-10-25 19.58.47.excalidraw]]

--- 

原型模式也可以用在游戏代码之外的数据建模中，比如说想要建立一个**怪物谱系**。

```json
     [
         {
             "name"： "slime",
             "maxHealth"： 100,
             "resists"： ["cold"，"posion"],
             "weakness"： ["fire"，"light"]
         },
         {
             "name"： "slime queen",
             "prototype"： "slime",
             "spells"： ["fire ball"，"ice nova"]
         },
         {
             "name"： "slime king",
             "prototype"： "slime",
             "attacks"： ["cyclone"，"charge"]
         }
     ]
```

通过为每个怪物json设置原型字段，可以有效实现相似怪物的属性共享。

![[游戏编程模式 2023-10-25 20.11.53.excalidraw]]

> [!hint]
> - 实现原型的clone时，一定要注意对象的拷贝问题（深拷贝，浅拷贝）。
> - [[游戏编程模式#类型对象|类型对象]]和和原型模式有一定的共同点。

# 单例模式

> [!quote]
> 确保一个类只有一个实例，并为其提供一个全局访问入口。

使用单例模式的一个经典场景是**日志系统**。

```python
class Logger(object):
	"""日志单例，不保证线程安全"""

	__instance = None

	@classmethod
	def GetInstance(cls):
		return cls()

	def __new__(cls):
		if __cls__.__instance is None:
			cls.__instance = super(self).__new__()
		return cls.__instance

	def Log(self, text):
		pass

```

通过`Logger.GetInstance()`, 所有的客户访问的都是一个**Logger**对象。

![[游戏编程模式 2023-10-25 20.39.22.excalidraw]]

> [!warning] 不要滥用单例模式
> - 他是一个全局变量
> 	- 由于任何位置都能修改单例，导致追踪问题时需要额外考虑全局单例状态，导致代码晦涩难懂。
> 	-  全局变量促进了耦合，由于单例的易访问性，使用者很可能在任何位置都不自主的使用单例，导致不相干的模块耦合到一起。
> 	- 对并发不友好。
> - 延迟初始化不一定是件好事，在错误的时间初始化可能导致游戏明显卡顿，所以很多时候会选择静态类初始化，此时单例没有意义。

> [!hint] 使用单例前的考量
> 1. 是否可以通过传参的方式替代单例
> 2. 是否可以在基类中获取
> 3. 是否可以将分散的单例作为成员变量封装到一个全局对象中
> 4. 使用[[游戏编程模式#服务定位器|服务定位器]]来访问
> 5. [[游戏编程模式#子类沙盒|子类沙盒]]可以为子类提供一些共享的状态访问，而不必全局可见
# 状态模式

> [!quote]
   允许一个对象在其内部状态改变时改变自身的行为，对象看起来好像在修改自身类。

使用状态模式的一个经典场景是**角色动画系统**。

```python
class AnimationState(object):
	def __init__(self, player):
		self._player = player
		self.PlayAnimation()

	def PlayAnimation(self):
		pass

	def GetNextState(self):
		pass

	def IsDone():
		pass


class IdleState(AnimationState):
	"""播放静止动画"""
	def GetNextState(self):
		if self._player.speed.x > 0:
			return WalkState(self._player)
		else:
			return self


class WalkState(object):
	"""播放行走动画"""
	def GetNextState(self):
		if self._player.speed.y > 0:
			return JumpState(self._player)

		if self._player.speed.x > 1:
			return RunState(self._player)
		elif self._player.speed.x <= 0:
			return IdleState(self._player)
		else:
			return self


class RunState(object):
	"""播放奔跑动画"""
	def GetNextState(self):
		if self._player.speed.y > 0:
			return JumpState(self._player)
	
		if self._player.speed.x > 1:
			return self
		else:
			return WalkState(self._player)


class JumpState(object):
	"""播放跳跃动画"""
	def GetNextState(self):
		if self._player.speed.y < 0:
			return self
		else:
			return DropState(self._player)


class DropState(object):
	"""播放下落动画"""
	def GetNextState(self):
		if self._player.speed.y == 0:
			return IdleState(self._player)
		else:
			return self

# 动画循环

state = IdleState(player)

while True:
	if state.IsDone():
		state = state.GetNextState()
```
   
使用状态机有效避免了同时维护多种状态和使用多个**if else**语句，每个状态只需要处理自己接受的输入并转换为对应的状态. 如果不使用状态机而只是单纯的使用**if else**语句，随着状态的增加会越来越难以维护(比如跳跃时是否可以下蹲?，是否可以攻击?)。

![[游戏编程模式 2023-10-26 13.40.44.excalidraw]]

> [!hint] 状态模式的使用场景
> - 你有一个游戏实体，它的行为基于它的内部状态而改变。
> - 这些状态被严格划分为相对数目较少的小集合。
> - 游戏实体随着时间变化会响应用户的输入和游戏事件。

---

状态机有多种分类：

- 有限状态机(FSM)
> [!summary] 定义
> - 你拥有一组状态，并且可以再这组状态之间切换。
> - 状态机同一时刻只能处于一种状态。
> - 状态机会接收一组输入或者事件。
> - 每个状态都有一组转换，每一个转换都关联着一个输入并指向另一个状态。

- 并发状态机
> [!summary] 定义
> 如果存在另一种类型的状态，和当前的状态无关，那么可以额外维护一个新的状态，用两个状态机而不是一个状态机来表示. 假设之前有n个状态，新增的有m个状态，那么使用一个状态机共有 $m*n$ 种状态要处理，而使用两个状态机只需要 $m+n$ 种状态。

- 层次状态机
> [!summary] 定义
> 如果很多状态有大量相似的状态，那么可以为这些状态设置父状态，当子状态无法处理输入时，交给父状态来处理，如果所有父状态都无法处理则忽略此输入。
> - 使用继承来实现，父类实现共性状态。
> - 不再使用一个状态变量，而是维护一个状态栈来实现，子状态在栈顶，下面依次是他的父状态，父状态的父状态，以此类推，栈底是祖先。

- 下推状态机
> [!summary] 定义
> 如果你的状态需要历史记录(当前状态结束想要回到上一个状态)，那么可以维护一个状态栈：
> - 当前状态永远在栈顶，当状态切换的时候，将当前状态压栈，然后将新状态入栈。
> - 当想切换到之前的状态时，将栈顶出栈即可。

# 双缓冲

> [!quote]
> 维护两个缓冲区，当前缓冲区和后台缓冲区。每当读取数据时，总是从当前缓冲区读取，每当修改数据时，总是修改后台缓冲区，当修改完成时，交换两者，使得当前缓冲区变为后台缓冲区以供复用。

使用双缓冲模式的一个经典场景是**图像渲染**。

```python
class FrameBuffer(object):
	WIDTH = 1920
	HEIGHT = 1080

	def __init__(self):
		self._pixels = []

	def Draw(self):
		for i in range(FrameBuffer.WIDTH):
			for j in range(FrameBuffer.HEIGHT):
				# draw pixel

	def SetData(self, data):
		self._pixels = data

	def Clear(self):
		self._pixels = []


class Scene(object):
	def __init__(self):
		self._front = FrameBuffer() # 用来显示图案
		self._back = FrameBuffer() # 用来写入数据

	def SetImage(self, data):
		self._back.SetData(data)
		self._front.Clear()
		self.Swap()

	def Draw(self):
		self._front.Draw()

	def Swap(self):
		self._front, self._back = self._back, self._front
```

通过维护两个缓冲，有效的避免了渲染的时候修改正在被渲染的数据导致画面撕裂，使用双缓冲的主要目的正是为了解决这两种情况：
- 状态直接被中断或者另一个线程的代码所访问。
- 进行状态修改的代码访问到了其正在修改的那个状态。

![[游戏编程模式 2023-10-26 15.25.56.excalidraw]]

> [!hint] 双缓冲的使用情景
> - 我们需要维护一些被逐步改变的状态量。
> - 同个状态可能在被修改的时候被访问到。
> - 我们希望避免访问状态的代码看到具体的工作过程。
> - 我们希望能够读取状态但不希望等待写入操作完成。
   
> [!hint] 缓冲区如何被交换
>  - 交换指针：简单高效，但是无法复用当前缓冲的数据。
>  - 数据拷贝：将后台数据拷贝到当前缓冲，当前永远落后后台一帧，可以实现数据复用对于小的缓冲区来说是可以接受的，但当缓冲区很大的时候复制会消耗大量时间。
# 游戏循环

> [!quote]
   实现用户输入和处理器速度在游戏进行时间上的解耦。
   >
   >通俗来说就是维护一个循环使游戏一直运转，同时可以不阻塞的响应用户的输入。
   
使用游戏循环的一个经典场景是大部分游戏引擎里**游戏主循环**本身。

---

基础版：
```python
while True:
	ProcessInput()
	Update()
	render()
```

这是游戏循环的核心逻辑，但是机能和一帧内处理的信息会影响游戏的速度，你无法控制游戏速度的快慢，在性能强劲的机器上和垃圾的机器上运行速度天差地别。

![[游戏编程模式 2023-10-26 19.03.20.excalidraw]]

---

同步固定时间步长：
```python
MS_PER_FRAME = 16.6 # 每秒钟60帧的速率

while True:
	startTime = time.time()

	ProcessInput()
	Update()
	Render()

	realCostTime = time.time() - startTime
	time.sleep(MS_PER_FRAME - realCostTime)
```

这种方法可以保证如果处理速度很快，游戏也会按照固定的速度的运行。但是如果游戏运行速度慢这个方法将退化到基础循环的情况。

![[游戏编程模式 2023-10-26 19.19.21.excalidraw]]

---

变时步长：
```python
lastUpdateTime = time.time()

while True:
	curTime = time.Time()
	elapsedTime = curTime - lastUpdateTime
	lastUpdateTime = curTime

	ProcessInput()
	Update(elapsedTime)
	Render()

```

首先这种方法让**Update**把间隔作为参数，确实可以让不同的硬件以相同的速度运行，但是有一个非常严重的问题，它会让游戏变得不稳定。因为不同机器update调用的次数是不一致的，快的多，慢的少，如果游戏内部有浮点数累加等操作，调用update会迅速累积大量误差。

![[游戏编程模式 2023-10-26 19.29.01.excalidraw]]

---

定时更新，变时渲染：

```python
MS_PER_FRAME = 16.6 # 每秒钟60帧的速率
lastUpdateTime = time.time()
lag = 0.0

while True:
	curTime = time.time()
	elapsed = curTime - lastUpdateTime
	lastUpdateTime = curTime
	lag += elapsed # 代表游戏时间落后于真实时间的值

	ProcessInput()

	while lag >= MS_PER_UPDATE:
		Update();
		lag -= MS_PER_UPDATE

	Render(lag/MS_PER_UPDATE)
```

这个是最具有普适性的游戏循环方法，通过将渲染和更新分离，可以适应过快或者过慢的平台，不同机器**Update**速度是一致的，但是性能好的机器可以 享受到更好的游戏体验(**Render**次数更多)。

![[游戏编程模式 2023-10-26 20.09.59.excalidraw]]

> [!hint] 游戏循环的使用场景
> 只要是游戏一定会用到，这就是91定律里面的10%部分的代码，这里的一点点错误会影响到整个游戏。

---

> [!summary] 游戏循环的控制权
> - 平台事件循环
> 	- 相对简单
> 	- 与平台完美兼容
> 	- 失去了对游戏时间的控制，而且实现理念很可能不适合于游戏
> - 游戏引擎游戏循环
> 	- 当出现一些和游戏引擎循环不合拍的需求时，你无法获得控制权
> - 自己编写游戏循环
> 	- 掌控一切，可以随心所欲
> 	- 需要实现各个平台接口，并且要定期将操作权交给系统来保证框架的稳定
   
# 更新方法

> [!quote]
  通过对所有对象实例同时进行帧更新来模拟一系列互相独立的游戏对象。
  >
  >通过为每个对象实现一个更新方法，游戏循环在每一帧对所有的对象调用其更新方法。

使用更新的一个经典场景是**怪物模拟**。

```python
class Entity(object):

	def __init__(self):
		self._x = 0
		self._y = 0

	def Update(self):
		pass

	def Move(self, dx, dy):
		self._x += dx
		self._y += dy


class Zombie(Entity):
	def Update(self):
		self.Move(5, 0)

class Statue(Entity):
	def Update(self):
		self.Move(0, 0)

# 主循环

allEntities = [Zombie(), Zombie(), Statue()]

while True:
	for entity in allEntities:
		entity.Update()

```

通过为每个实体实现各自的**Update**函数，每个实体可以只关注自身的行为，游戏循环也不需要关心每个实体具体的更新方式，非常易于维护和增加新的实体行为。

![[游戏编程模式 2023-10-26 21.14.18.excalidraw]]

> [!hint] 更新模式的使用场景
> - 你游戏里有一系列对象需要同步的运转
> - 各个对象之间的行为几乎是独立的
> - 对象的行为与时间有关

> [!summary] 未激活对象的处理方式
> - 如果使用单个集合来存储所有对象
> 	- 需要用标识位来指明对象的有效性，如果无效对象较多可能会大量的时间，而且也会破坏[[游戏编程模式#数据局部性|数据局部性]]。
> - 如果维护一个集合专门存储活跃对象
>     - 你需要用两份内存来维护对象，但是速度上会有很大的提升。
>     - 必须要保持两个集合同步。

> [!hint]
> 这一部分与[[游戏编程模式#游戏循环|游戏循环]]和[[游戏编程模式#组件模式|组件模式]]共同构成了游戏引擎的核心部分。
# 字节码

> [!quote]
   通过将行为编码成虚拟机指令，从而使其具备数据的灵活性。
  > 
   指令集定义了一套可以执行的底层操作。 一系列指令被编码为字节序列，虚拟机逐步执行指令栈上的这些指令，通过组合指令，即可完成高级行为。
   
使用字节码的一个经典场景是**法术API**。

```python
# 功能函数

def PlaySound(id):
	pass

def SetHealth(witchID, value):
	pass

def GetHealth(witchID):
	pass

def SpawnParticles(id):
	pass


class Instruction(IntEnum):
	"""支持的指令集"""
	INST_LITERAL = 0x00,
	INST_SET_HEALTH = 0x01
	INST_GET_HEALTH = 0x02
	INST_ADD = 0x03
	INST_PLAY_SOUND = 0x04
	INST_SPAWN_PARTICLES = 0x05

class VM(object):
	"""虚拟机，用来解释指令"""

	def ParseLiteral(self, value, *args):
		self._stack.append(value)
		return 1

	def ParseSetHealth(self, *args):
		hp = self._stack.pop()
		id = self._stack.pop()
		SetHealth(id, hp)
		return 0

	def ParseGetHealth(self, *args):
		id = self._stack.pop()
		self._stack.push(GetHealth(id))
		return 0

	def ParseAdd(self, *args):
		self._stack.append(self._stack.pop() + self._stack.pop())
		return 0

	def ParsePlaySound(self, *args):
		PlaySound(self._stack.pop())
		return 0

	def ParseSpawnParticles(self, *args):
		SpawnParticles(self._stack.pop())
		return 0

	InstructionTable = {
		Instruction.INST_LITERAL: ParseLiteral,
		Instruction.INST_SET_HEALTH: ParseSetHealth,
		Instruction.INST_GET_HEALTH: ParseGetHealth,
		Instruction.INST_ADD: ParseAdd,
		Instruction.INST_PLAY_SOUND: ParsePlaySound,
		Instruction.INST_SPAWN_PARTICLES: ParseSpawnParticles,
	}

	def __init__(self):
		self._stack = [] # 指令栈

	def Interpret(self, code):
		i = 0
		while i < len(code):
			func = self.InstructionTable[code[i]]
			step = func(self, *code[i+1:])
			i += (step+1)
```

如果想要模拟一个将第一个巫师的生命值设置为两个巫师生命总和的法术，假设巫师1生命为20，巫师2生命为40。可以执行以下字节码：

   | bytecode        | vm stack    | comment           |
   | --------------- | ----------- | ----------------- |
   | INST_LITERAL 1  | [1]         | 设置巫师1 id  |
   | INST_LITERAL 1  | [1，1]      | 设置巫师1 id  |
   | INST_GET_HEALTH | [1，20]     | 获得hp数值 |
   | INST_LITERAL 2  | [1，20，2]  | 设置巫师2 id   |
   | INST_GET_HEALTH | [1，20，40] | 获得hp数值 |
   | INST_ADD        | [1，60]     | 相加        |
   | INST_SET_HEALTH | []          | 设置hp数值 |

虽然只实现了一个支持很小指令集的虚拟机，但是已经可以通过组合实现很多法术效果，并且由于字节紧密排列，执行的速度非常快。由于我们只提供了有限的指令，任何通过字节码执行的行为都不会对游戏产生破坏。

![[游戏编程模式 2023-10-26 22.55.13.excalidraw]]

> [!hint] 字节码使用场景
> 如果你的游戏中需要定义大量行为，并且实现的语言有如下特征：
> - 编程语言太底层了，编写起来繁琐易错。
> -  因为编译时间或者其他原因，迭代缓慢。
> - 它的安全性很低，想要确保定义的行为不会让行为崩溃，需要把他们从代码库移到沙箱。

---

> [!hint]
> 1. 如果使用字节码，一定要控制字节码的规模，在他超出你的控制之前一定约束好范围
> 2. 指令应该如何访问堆栈?
> 	- 基于栈的虚拟机 **[推荐]**
>		- 指令很小，因为参数隐式位于栈顶
>		- 代码生成简单
>		- 指令数量更多
>	- 基于寄存器的虚拟机
>		- 指令更大，因为需要记录参数在栈中的偏移量
>		- 代码生成复杂
>		- 指令更少，性能更高
> 3. 应该有哪些指令?
> 	- 外部基本操作，比如播放动画，声音等等。
> 	- 内部基本操作，操作虚拟机栈内值得操作，比如运算，比较等等。
> 	- 控制流，为栈实现跳转功能，即修改栈顶指针的位置。
> 	- 抽象化，提供可调用过程，本质上也是跳转，不过需要记录返回的地址。
> 4. 值应当如何表达?
>	- 单一数据类型
>		- 很简单
>		- 表达能力很差
>	- 标签表达，每个值由两部分组成，一个是它的类型，一个是它的值。**[推荐]**
>		- 运行时可以完成对值的检查，很安全
>		- 占用更多的内存
>	- 接口 **[不建议使用，使用多态会严重降低效率]**
> 5. 如何生成字节码?
>	- 定义一种基于文本的语言，类似lua，python。
>		- 你要定义语法，定义一个对用户友好的语言是很困难的
>		- 你要实现一个分析器
>		- 你必须处理语法错误
>		- 对非技术人员不友好
>	- 实现一个图形化界面来编辑操作 **[推荐]**
>		- 操作友好
>		- 不容易出错，因为你可以在ui里限制用户的操作
>		- 移植性较差

--- 

> [!note] 与其他模式的联系
> 字节码是[[设计模式#解释器模式|解释器模式]]的兄弟版，他们都提供了一种用数据来组合行为的方法，事实上生成字节码的工具经常会有一个内部对象树来表达代码，遍历解析它来生成字节码, 这正是[[设计模式#解释器模式|解释器模式]]做的事。他们的区别在于字节码只在生成阶段使用[[设计模式#解释器模式|解释器模式]]，执行阶段使用更加高效的字节码。
# 子类沙盒

> [!quote]
   使用基类提供的操作集合来定义子类中的行为。
>
   基类定义出抽象的沙盒方法和一些预定义的操作函数，通过将他们设为保护状态来确保只被子类使用，每个派生出来的子类使用父类提供的操作来实现沙盒函数。
  
使用子类沙盒的一个经典场景是**超级英雄系统**。

```python
class SuperPower(object):
	def Move(self, double x, double y):
		pass

	def PlaySound(self, soundID):
		pass

	def SpawnParticles(self, type, count):
		pass

	def Activate(self):
		pass


class IronMan(SuperPower):
	def Activate(self):
		self.Move(100, 100)
		self.PlaySound(10)


class SpiderMan(SuperPower):
	def (self):
		self.Move(10, 10)
		self.SpawnParticles(web, 100)
```

实际上是一个非常温和的模式，父类封装一些子类可能用到的操作，子类调用即可。这种方式将耦合全部集中到了父类，子类会很清爽。

![[游戏编程模式 2023-10-27 00.46.08.excalidraw]]

> [!hint] 使用场景
> - 你有一个带有大量子类的基类
> - 基类能够提供所有子类可能需要执行操作的集合
> - 子类之间有重复的代码
> - 你希望子类和其他部分最小耦合

--- 

> [!hint]
> 1. 需要提供的操作
>	- 如果基类提供的方法只被少数子类使用，那么不必将其加入基类。
>	- 如果某个耦合是非侵入性的(即不修改任何状态)，那么它是非常安全的，那么可以放到子类中，反之应该放到基类。
>	-  如果仅仅是提供系统调用的二次封装，有些时候可能不需要在基类包装(这个要具体分析)。
> 2. 为子类提供什么样的操作
>	   一般来说是提供函数供子类调用，但是如果有大量的某个模块的相关函数，可以将他们包装到一个新的类中，基类提供这个类的实例供子类调用，有如下优点：
>	- 减少了基类函数数量
>	- 辅助类和基类都更加容易维护
>	- 降低了基类和其他模块的耦合
> 1. 基类如何初始化依赖状态
>	- 构造函数初始化 ：这是最简单的方案，但是每个子类都要承担起初始化基类的责任, 不方便修改。
>	- 分段初始化 ：提供一个`Init`函数，但是有可能有忘记调用的风险，可能需要包装一个工厂函数来降低这种风险
>	- 静态初始化 ： 可以将基类依赖的对象静态化(如果可以)，可以确保所有子类共享一个实例。
>	- [[游戏编程模式#服务定位器|服务定位器]] ： 不在基类内部持有依赖对象，在调用函数的时候使用动态获取。

---

> [!note] 与其他模式的联系
> - [[游戏编程模式#更新方法|更新]]一般也是一个沙盒函数
> - [[设计模式#模板函数模式|模板函数模式]]与沙盒相反，它是基类定义骨架，子类来实现
> - 可以将此模式当成[[设计模式#外观模式|外观模式]]的一个变种
# 类型对象

> [!quote]
   通过创建一个类来支持新类型的灵活创建，其每个实例都代表不同的对象类型。
   >
   定义一个类型对象和一个持有类型对象的类，每个类型对象实例表示一个不同的逻辑类型，每个持有类型对象的类引用一个描述其类型的类型对象。
   
使用类型对象的一个经典场景是**怪物生成系统**。

```python
class Attr(object):
	def __init__(self):
		self.Attack = 10
		self.HP = 10
		# ... other attr

class Species(object):
	"""种类就是怪物的模板，每一个种类的实例都存储了一种怪物的属性"""
	def __init__(self, parent=None, attr=None):
		self._parent = parent
		if self._parent:
			self._attr = attr or parent.GetAttr()
		else:
			self._attr = attr or Attr()

	def GetAtk(self):
		return self._attr.Attack

	def SpawnMonster(self):
		return Monster(self)


class Monster(object):
	"""一个具体的怪物"""
	def __init__(self, species):
		self._species = species

	def GetAtk(self):
		return self._species.GetAtk()
```

每一个**Species**的实例都是一个新的怪物类型，只需要两个类就可以创造无限的怪物体系，并且实例可以在运行时动态创建，修改数据无需重新编译。模拟的单继承也可以实现怪物类型的继承结构。

![[游戏编程模式 2023-10-27 22.36.07.excalidraw]]

> [!hint] 类型对象的使用场景
> 当你需要定义一系列不同种类的东西，却又不想将它们硬编码，尤其是以下条件成立时：
> - 你不知道将来会有什么类型。
> - 你需要在不重新编译的情况下，修改或添加新的类型。

---

> [!hint]
> 1. 使用的时候要注意两点：
>	- 确保类型实例存在
>	- 类型对象处理数据比较容易，处理行为比较困难，可以通过以下方法：
>		- 创建一个预定义的行为集合，在每个类型里面持有可以访问行为的对象。
>		- 采用数据来定义行为，比如[[设计模式#解释器模式|解释器模式]]或者[[游戏编程模式#字节码|字节码]]来定义行为。
> 2. 类型对象应该封装还是暴露?
>	- 如果类型被封装在持有对象里
>		- 类型对象变为了实现细节，降低了代码复杂度。
>		- 持有对象可以选择性的重写部分类型对象的行为。
>		- 需要给类型对象所有暴露的接口提供转发函数。
>	- 如果类型对象被持有对象公开
>		- 外部对象可以通过怪物实例即可访问类型对象。
>		- 将窄接口变宽了，降低了维护性，提高了复杂度。
> 3. 持有对象里的类型是否运行时可变?
>	- 类型不变
>		- 编码和理解起来都更简单，更加容易调试
>	- 类型可变
>		- 减少了对象的创建次数
>		- 在切换类型时要注意约束对象的状态

 --- 

> [!note] 和其他模式的联系
>- 和[[游戏编程模式#原型模式|原型模式]]的共同点在于它们都用来处理如何在不同对象之间共享数据。
>- 和[[游戏编程模式#享元模式|享元模式]]的区别在于，享元模式着重于节省内存，而此模式在于组织性和灵活性。
>- 和[[游戏编程模式#状态模式|状态模式]]都把部分工作交给另一个代理对象。
# 组件模式

> [!quote]
   允许一个单一的实体跨越多个不同域而不会导致耦合。
   >
   单一实体横跨了多个域，为了能够保持域之间的相互隔离，每个域的代码都独立的放在自己的组件类里，实体本身简化为组件的容器。

使用组件模式的一个经典场景就是**游戏实体**。

```python
class GameObject(object):
	"""游戏对象"""
	def __init__(self):
		self._components = []

	def AddComponent(self, comp):
		self._components.append(comp)

	def GetComponent(cls):
		for comp in self._components:
			if isinstance(comp, cls):
				return comp
		else:
			return None

	def Display(self):
		"""在指定的位置渲染图像"""
		transform = self.GetComponent(Transform)
		texture = self.GetComponent(Texture)
		texture.SetPos(transform.x, transform.y)
		

class Transform(object):
	def __init__(self, x, y):
		self.x = x
		self.y = y


class Texture(object):
	def __init__(self, imgPath):
		self._img = open(imgPath)

	def SetPos(x, y):
		pass


obj1 = GameObject()
obj1.AddComponent(Transform(3, 3))
obj1.AddComponent(Texture("C:/aa.png"))
```

通过将游戏实体的操作分担给各个组件对象，可以通过灵活的组合来创建满足所有需求的游戏实体，实现了游戏实体和其他组件实体的解耦。

![[游戏编程模式 2023-10-28 00.07.34.excalidraw]]

> [!hint] 使用场景
> - 你有一个涉及多个域的类，但是你希望多个域之间保持隔离。
> - 一个类越来越庞大，难以开发。
> - 你希望定义许多共享不同能力的对象，但采用继承又无法让你精准的重用代码。

> [!hint]
> 1. 对象如何获得组件?
>	- 如果实体自己创建自己需要的组件
>		- 确保了类一定能够正确的初始化自己需要的组件
>		- 丧失了灵活性
>	- 由外部代码提供
>		- 对象变得非常灵活
>		- 对象可以从具体的组件对象中解耦
> 2. 组件之间如何传递消息?
>	- 通过修改组件容器对象的状态
>		- 组件解耦，互相之间不知道对方存在。
>		- 会将组件容器变得混乱，因为有些状态是某些组件不需要的。
>		- 状态的修改顺序将会决定程序的运行结果，非常容易导致bug。
>	- 组件之间相互引用
>		- 简单快速
>		- 组件之间出现了局部耦合，但基本可控。
>	- 通过消息事件，消息队列来传递
>		- 组件解耦
>		- 容器对象可以保持简单

---

> [!note] 和其他模式的联系
> 和[[设计模式#策略模式|策略模式]]非常相似，只不过策略模式一般都没有状态，只是一个算法，而组件一般是包含状态的。
# 事件队列

> [!quote]
   对消息或事件的发送和受理进行时间上的解耦。
  > 
   通过一个先进先出的队列存储一系列通知或请求，发出通知后系统会将请求置入队列并立即返回，随后处理器从事件队列获取感兴趣的事件并处理这些请求。这一过程将使消息的发送者和受理者解耦，使得对消息的处理变得动态且非实时。

使用事件队列的一个经典场景是**音效播放管理**。

```python
class PlayInfo(object):
	SoundID = 0
	Volume = 0

class AudioManager(object):

	def __init__(self):
		self._pending = []
		
	def PlaySound(id, volume):
		_pending.append(PlayInfo(id, volume))

	def Update():
		if _pending:
			info = _pending.pop(0)
			channel = FindAvailableChannel()
			channel and StartPlaySound(channel, info.SoundID, info.Volume)
			
```

通常会将`AudioManager`放到一个单独的线程专门处理声音播放，通常会对这个类进行一些线程安全的处理以防发生竞争。通过事件队列，将播放声音的请求和实际播放的操作解耦，将播放声音的请求变为了一个异步接口。

![[游戏编程模式 2023-10-28 16.05.12.excalidraw]]

> [!hint] 事件队列使用情景
   当你对某个问题上在时间进行解耦时，使用事件队列。

> [!hint]
> 1. 注意事项。
>	- 事件队列一般是全局变量，全局变量一般是糟糕的
>	- 事件队列里面的消息并不是实时的，当你处理的时候很有可能环境已经发生了变化
>	- 事件处理方一般不要发送事件，这很可能导致反馈循环
> 2. 入队的是什么?
>	- 如果是事件(描述已经发生的事情，类似异步的观察者)
>		- 你会允许多个监听器
>		- 可访问队列的域会更广
>	- 如果是消息(我们希望在将来发生的行为，类似异步API)
>		- 一般只有一个监听器
> 3. 谁能从队列里读取?
>	- 单播队列
>		- 队列成为消息处理者的实现细节，封装性更好
>		- 你不必担心多个监听器竞争的情况
>	- 广播队列
>		- 事件可以被删除，如果某个时刻没有监听器，事件会被丢弃
>		- 可能需要过滤事件，监听器需要过滤收到的事件
>	- 工作队列(每个事件只会被一个监听者处理的广播队列)
>		- 需要做好规划，找到处理事件的最优监听者
> 4. 谁可以写入队列?
>	- 一个写入者
>		- 你隐式的知道事件的来源
>		- 通常允许多个读取者
>	- 多个写入者
>		- 小心反馈循环，因为任何东西都可能放入队列之中
>		- 你可能想要得到发送方的引用，事件里面可能需要存储发送方本身
> 5. 注意队列对象的生命周期。

---

> [!note] 和其他模式的联系
> 可以将事件队列理解为[[游戏编程模式#观察者模式|观察者模式]]的异步版本。

# 服务定位器

> [!quote]
> 为某服务提供一个全局访问入口来避免使用者与该服务具体实现类之间产生耦合。
> 一个服务类为一系列操作定义了一个抽象的接口，一个具体的服务提供器实现这个接口，服务类屏蔽了提供器的具体类型以及定位服务的过程。
>
> 通俗的来讲，类似公共电话本，你把你的电话提供给公共电话本，其他人通过查询电话本来查看你的号码，而不是直接拥有你的号码，这样当你修改自己的号码时只需要告诉电话本即可，而不需要告诉每一个知道你电话的人。

使用服务器定位的一个经典场景是**日志系统**。

```python
class Logger(object):
	def Log(self, text):
		pass


class FileLogger(Logger):
	def Log(self, text):
		fp = open("log.txt", "a+")
		fp.write(text)


class ConsoleLogger(Logger):
	def Log(self, text):
		print(text)


class Locator(object):
	_service = Logger()

	@classmethod
	def GetLogger(cls):
		return cls._service

	@classmethod
	def Provide(cls, service):
		cls._service = service

# 用法
Locator.Provide(FileLogger())
Locator.GetLogger().Log("Hello world!")
```

通过提供默认服务来避免没有提供服务导致的异常，通过`Locator`的抽象使得我们可以动态替换日志服务的功能，非常健壮灵活。

![[游戏编程模式 2023-10-28 16.45.50.excalidraw]]

> [!hint] 服务定位器使用场景
> - 服务定位器也是全局变量，谨慎使用，本质上是一个灵活的[[游戏编程模式#单例模式|单例模式]]。
> - 在使用此模式之前有限考虑能不能将对象作为一个参数传入，提供直观的耦合可以满足大部分需求。
> - 有一些基础系统(日志，音频，渲染)，为了让底层使用而传递了很多层是毫无必要的，此时可以使用服务定位器。

> [!hint]
> 1. 服务如何被定位?
>	- 外部代码注册
>		- 简单快捷
>		- 我们控制了提供器如何构建
>		- 可以运行时动态替换提供器
>		- 使用前必须要注册，不然可能导致bug
>	- 编译时绑定
>		- 简单快速
>		- 可以保证服务可用，定位器里可以确定进行了初始化
>		- 不便于修改，每次修改需要重新编译
>	- 在运行时配置
>		- 重量级解决方案，需要一个配置系统
>		- 定位服务需要消耗时间
>		- 非程序人员也可以更换提供器
>		- 一份代码库支持多分配置
> 2. 当服务不能被定位时发生什么?
>	- 让使用者解决，使用者必须解决失败，但是也提供了灵活性
>	- 终止游戏
>		- 使用者不需要处理丢失的服务
>		- 大型工作团队因为游戏终止可能会浪费大量的时间
>	- 返回一个空服务
>		- 使用者不需要处理丢失的服务
>		- 当服务不可用时，游戏还可以继续运行(双刃剑，难于寻找bug)
> 3. 服务定位器的域
>	- 全局访问
>		- 鼓励整个代码库使用一个服务
>		- 对何时何地使用服务失去了控制
>	- 如果限制到类中
>		- 控制了耦合
>		- 可能会导致重复的工作，可能很多类都需要这个定位器，但是都需要各自处理。
>
> > [!summary]
> > 一般原则是，如果服务只在一个域之中使用，那么便限制到类中。如果更广泛的服务，比如日志系统，应该是全局的。

# 数据局部性

> [!quote]
   通过合理组织数据利用cpu的缓存机制来加快内存访问速度。
   >
   当代cpu带有多级缓存来提高内存访问速度，通过让数据在内存连续分布来提高速度。

使用数据局部性的一个经典场景是**冷热分解**。

```python
class AIComponent(object):
	def __init__(self):
		# 热数据，每次更新都会用到
		self._anim = Animation()
		self._pos = (0, 0)

		# 冷数据，不常用
		self._loot = LootList()

class LootList(object):
	def __init__(self):
		self.List = [1, 2, 3, 4, ]
```

通过将掉落列表存储为一个类实例的引用，减小组件的大小从而提高cpu一次能够缓存的数量，由于冷数据并不是经常使用所以也不会导致cpu访问指针导致频繁未命中。

![[游戏编程模式 2023-10-29 00.20.59.excalidraw]]

> [!hint] 数据局部性的使用场景
> 确认游戏性能的瓶颈确实是由缓存未命中引起的。

> [!hint]
> 1. 如何处理多态?
> 	为了实现局部性很可能需要牺牲一部分抽象，继承。他们的优势一般都是通过指针来实现的，但是指针跳转会导致未命中，这里需要权衡。
>	- 避开继承
>		- 安全且容易
>		- 速度更快
>		- 灵活性变差
>	- 为不同的类型对象使用互相独立的数组
>		- 这一系列的集合能够让对象紧密排列
>		- 你可以静态的进行调用分发
>		- 你必须时刻追踪这些集合
>		- 你必须维护每一种类型，无法解耦
>	- 使用指针集合
>		- 灵活性高，可扩展
>		- 对缓存不友好
> 1. 游戏的实体如何定义
>	- 通过类的指针来索引组件
>		- 你可以将组件存储于相邻的数组中
>		- 对于给定的实体，你可以很轻松的通过指针访问组件
>		- 在内存中移动很困难
>	- 假如游戏实体通过id索引其组件
>		- 更加复杂且更加缓慢
>		- 你需要组件管理器，以便通过id查找组件
>	- 假如游戏实体本身就是id
>		- 你的游戏实体类完全消失，完全依赖于组件模式
>		- 你无需管理其生命周期
>		- 检索一个实体的所有组件会很慢

---

> [!note] 和其他模式的联系
[[游戏编程模式#组件模式|组件模式]]是实现数据局部性最常用的方法。
# 脏标记模式

> [!quote]
   将工作推迟到必要时进行计算以避免不必要的工作。
   >
   一组原始数据随时间变化，一组衍生数据通过昂贵的操作由原始数据生成。设置一个脏标记来跟踪衍生数据是否和原始数据同步。如果标记发生改变则重新计算数据，如果未变则使用缓存的衍生数据。

脏标记模式一个比较经典的应用场景就是**场景渲染**。

```python
class Transform(object):
	Origin = (0, 0) # 原点

	def Combine(Transform other):
		"""结合两个变换，生成新的变换"""
		pass


class GameObject(object):
	def __init__(self):
		self._local = Transform.Origin
		self._world = Transform.Origin
		self._children = []
		self._dirty = True

	def SetTransform(self, localTransform):
		self._local = localTransform
		self._dirty = True

	def Render(self, parentTransform, isDirty):
		dirty = isDirty or self._isDirty # 只要父变换修改过，就一定要设置标记
		self._dirty = False
		
		if dirty:
			self._world = self._local.Combine(parentTransform)

		RenderToGraphic(self._world)

		for child in self._allChildren:
			child.Render(self._world, dirty)
		
	
```

通过加入脏标记和缓存，可以使得没变化的对象不需要重新计算，变化了的对象无论它的父节点如何变换，最终自身只需要计算一次变换。

![[游戏编程模式 2023-10-29 01.07.30.excalidraw]]

> [!hint] 使用场景
> 此模式用于解决相当特定的问题，仅当性能问题严重到值得增加代码复杂度时才使用它。使用前要满足以下的要求：
> - 原始数据修改次数比衍生数据的使用次数要多，如果每次原始数据修改都需要修改衍生数据，那脏标记毫无意义。
> - 很难递增更新数据

> [!hint]
> 1. 使用代价
>	- 延时计算是有代价的，很多时候很多数据为了用户体验需要提前计算，延时计算可能导致明显的卡顿。
>	- 必须保证每次改动都设置脏标记，可以提供一个接口专门用来修改，并在接口里设置脏标记。
>	- 必须要在内存中保存数据。
> 2. 何时清除脏标记?
>	- 当需要计算结果时
>		- 当原始数据变化频率远大于衍生数据访问时，优化效果显著
>	- 精心设计的检查点，比如存档
>		- 这些工作不影响用户体验
>		- 工作执行时你失去了控制权
>	- 后台，启动定时器
>		- 你可以调整频率
>		- 你可以做更多冗余的工作
>		- 需要支持异步操作
> 3. 脏标记的追踪粒度
>	- 更精细的粒度，只追踪真正改动的数据。
>	- 更粗糙的粒度，需要处理一些没有修改过的数据。
# 对象池

> [!quote]
   使用固定的对象池重用对象，取代单独地分配和释放对象，以此来达到提升性能和优化内存使用之目的。
   >
   定义一个可重用集合的对象池类，每个对象支持提供自身使用状态的方法。对象池初始化 时预先创建整个集合，当你向对象池请求时会返回一个未使用的对象，当对象不使用时将其置为未使用状态。

使用对象池一个比较经典的应用场景就是**粒子播放器**。

```python
class Particle(object):
	def Emit(self, lifetime):
		pass

	def IsInUse(self):
		"""是否还在使用中"""
		pass


class Pool(object):
	POOL_SIZE = 5
	def __init__(self):
		self._pool = [Particle() for _ in range(self.POOL_SIZE)]

	def CreateParticle(self):
		"""返回一个未使用的对象"""
		for obj in self._pool:
			if not obj.IsInUse():
				return obj
		else:
			return None

```

通过维护一个对象池，粒子对象的创建不需要通过内存管理，而是一次性申请一块内存自己进行管理，有效的防止了产生碎片化内存。

![[游戏编程模式 2023-10-29 15.16.05.excalidraw]]

> [!hint] 对象池使用场景
> - 你需要频繁的创建销毁对象。
> - 对象大小一致。
> - 每个对象封装着获取代价昂贵且可重用的资源，如数据库，网络连接。

> [!hint]
> 1. 使用代价
>	- 对象池会浪费一定内存，未使用的对象也会占用内存
>	- 对象池的对象由自己管理，不会被自动清理(0xdeadbeef)
> 2. 对象池已经用干时如何处理新的请求？
>	- 阻止申请，可以确保不会溢出
>	- 不创建对象
>	- 删除一个现有对象
>	- 增加对象池的大小
> 3. 如果存在许多不同大小的对象，建议创建多个不同大小的内存池，而不是使用同一个。这也是内存分配的管理模式。
> 4. 对象是否被加入对象池?
>	- 假如对象池和对象耦合
>		- 实现很简单
>		- 你可以保证对象只由对象池创建
>		- 可以避免存储一个代表"使用中"的标识位，因为对象知道自己被对象池使用，可以提供一个代表自身状态的函数
>	- 如果独立于对象池
>		- 你得到了一个通用的对象池类
>		- 外部必须有办法追踪每个对象的使用状态，最简单的方式就是使用标识位
> 5. 谁来初始化对象?
>	- 在对象池内部初始化
>		- 对象池可以完全封装对象的初始化
>		- 对象池可能要提供多种初始化函数，和对象的初始化方法数量相关
>	- 在对象池外部初始化
>		- 对象池的接口会更简单
>		- 外部需要处理对象创建失败的情况

---

> [!note] 和其他模式的联系
> [[游戏编程模式#享元模式|享元模式]]也包含对象的重用，他们的区别在于，这个是时间上的重用；而享元是空间上的重用。
# 空间分区

> [!quote]
   将对象存储在根据位置组织的数据结构中来高效的定位它们。
   >
   对一组对象而言，每个对象都有一个位置，将位置存储在合适的数据结构中以便能够高效查询周围的对象，当位置变化时也要更新数据结构以便继续查询。

使用空间分区一个比较经典的应用场景就是**方格战场**。

```python
class Unit(object):
	def __init__(self, x, y):
		self.X = x
		self.Y = y


class Grid(object):
	WIDTH = 3
	HEIGHT = 3
	def __init__(self):
		self._array = []

	def AddUnit(unit):
		"""根据单位坐标将其划分到9宫格里"""
		pass

	def FindNearUnit(unit):
		"""寻找单位的相邻单位，九宫格的话最多有5个格里的单位可能和其相邻"""
		pass
```

通过根据对象坐标将对象分区，使得战斗仅检测在相邻网格中进行，有效提高了性能。

![[游戏编程模式 2023-10-29 15.37.09.excalidraw]]

> [!hint] 使用场景
> - 必须有一组对象，并且都具有位置信息。
> - 你确实遇到了性能问题(只有几个单位很显然没有性能问题)。
> - 确保你的时间比空间更宝贵(本质上是空间换时间的数据结构)。

> [!hint]
> 1. 分区是层级还是扁平的
>	- 扁平的
>		- 相对简单，数据结构更加容易实现
>		- 内存使用量恒定
>		- 当对象改变位置时可以快速更新(不需要改变多个层级)
>	- 层级的
>		- 可以更有效的处理空白空间，一个少量单位的空白区间只占用一个区间
>		- 更加有效地处理稠密的区间，会将其递归分为若干小区间
> 2. 分区依赖于对象集合吗?
>	- 不依赖于对象
>		- 对象可以逐步的添加
>		- 对象可以快速的移动
>		- 分区不平衡
>	- 分区不依赖于对象，层级依赖于对象(**四叉树**)
>		- 对象可以逐步的添加
>		- 对象可以快速的移动
>		- 分区是平衡的
> 3. 对象只存储于分区中吗?
>	- 如果是唯一存储对象的地方
>		- 避免了维护两个集合的内存开销和复杂性，不必维护其同步
>	- 如果存在另一个集合
>		- 遍历所有对象会更加快速，可以用一个集合维护有效对象

---

> [!summary] 常见分区数据结构
> - [k-d树](https://zhuanlan.zhihu.com/p/53826008)
> - [层次包围盒](https://blog.csdn.net/sunshine543123/article/details/107041122)
> - [四叉树](https://blog.csdn.net/zhouxuguang236/article/details/12312099)

[^1]: mvc是一种软件架构模式，将应用程序分为模型，视图和控制器并让他们相互分离，独自变化，以便于开发，测试，维护。