---
outline: true
---
[[📚大纲（设计模式）|模式]]与重构之间存在着与生俱来的关系，模式是重构的目标，重构是达到目标的方法。

> [!hint]
> 如果你发现自己需要为程序添加一个特性，而代码结构无法使你很方便地达成目的，那就先重构那个程序，让特性易于添加，然后再添加特性。

> [!hint]
> 重构前，先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。

> [!hint]
> 重构技术就是以微小的步伐修改程序。如果你犯下错误，很容易便可发现它。

> [!hint]
> 任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。

# 重构原则

## 何为重构

重构就是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

> [!quote]
> 添加新功能时，你不应该修改既有代码；重构时你只需改善程序结构，不要添加新功能。

## 为何重构

1. 重构改进了软件设计，消除了重复代码。
2. 重构使得代码更加容易理解，让扩充功能更加简单。
3. 重构的过程中会加深对代码的理解，更容易找到bug。
4. 重构之后提高了设计质量，而良好的设计是快速开发的根本，所以整体的开发速度会更快。

## 何时重构

重构不需要专门拨出时间来进行，重构应该随时随地进行。

- 添加功能时重构：当源代码难以增加功能时，进行重构。
- 修补错误时重构：因为代码还没清晰到让你一眼看出bug，所以需要重构。

> [!hint] 三次法则
> 第一次做时只管去做，第二次做类似的事会有反感，但还是去做，第三次再做类似的事则重构。

## 重构的难题

- 数据库：一般通过在对象模型和数据库模式中插入中间层来分隔两变的变化。
- 修改接口：如果你的接口没有公开发布，你可以随便修改，因为你有办法同时处理所有的调用处，否则最好保留旧接口并让其调用新的接口。
- 不该进行重构：当现有代码根本无法正常运行，你应该直接重写；当马上临近最后期限时，你也不该进行重构。

## 重构与设计

有了重构之后，你没必要找出一个完美的设计方案，只要实现一个相对合理的方案就够了。在不断的开发中根据需求进行重构，让方案更加完美。

重构可以带来更简单的设计，同时不损失灵活性，这降低了设计的压力。所以当下我们总是建造可运行的最小系统。

## 重构与性能

一般有三种做法：

1. 时间预算法：设计时对每个部分占用的时间都要做好预算，每个组件都不能超出自己的预算。这种只适用于要求极高的实时系统。
2. 持续关注法：写任何代码时都设法保持系统的高性能。但这种方式通常不会有太大的作用，因为90%时间都消耗在10%的代码上，你大部分的优化都是无用功。
3. 后期优化法：前期编写代码时主要维护代码的良好结构，可读性，不会关注性能。后期进入性能优化阶段，会寻找热点，对热点进行针对性的优化。

总体来说第三种是比较科学的性能优化方案。使用重构手法我们可以更快的开发程序，留出更多的时间寻找性能热点，而良好的代码结构使得更容易对性能进行优化。

# 代码的坏味道

何时重构代码？当你浏览代码时察觉到以下的“坏味道”，那么你就该进行重构了。

## 重复代码

^Duplicated-code

如果你在一个以上的地点看到了相同的程序结构，那么可以肯定将它们合为一体会更好。

> [!summary] 相关重构手段
> - 最基础的手法是[[提炼函数|Extract Method]]。
> - 两个互为兄弟的子类内有重复代码，考虑[[函数上移|Pull Up Method]]，[[塑造函数模板|Form Template Method]]，[[替换算法|Substitute Algorithm]]。
> - 两个不相干的类出现重复代码，考虑[[提炼类|Extract Class]]。

## 过长函数

^Long-Method

我们应当更加积极的分解函数。每当感觉应该用注释说点什么的时候，我们就需要把需要说明的内容放到一个独立函数里，并以其用途给它命名。

> [!summary] 相关重构手段
> - 最基础的手法是[[提炼函数|Extract Method]]。
> - 如果函数内有大量的临时变量和参数，使用[[以查询取代临时变量|Replace Temp with Query]]消除临时变量，使用[[引入参数对象|Introduce Parameter Object]]和[[保持对象完整|Preserve Whole Object]]来简化过长的参数列表。如果这样做完后还是有很多临时变量和参数，那么就用杀手锏[[以函数对象取代函数|Replace Method with Method Object]]。
> - 条件表达式也是提炼的信号，可以使用[[分解条件表达式|Decompose Conditional]]来处理。
> - 循环语句应该和其内容使用[[提炼函数|Extract Method]]放到一个新的函数中。

## 过大的类

^Large-Class

如果想用单个类做太多的事情，其内往往就会出现很多实例变量。一旦如此，重复代码也就随之而来了。

> [!summary] 相关重构手段
> - 使用[[提炼类|Extract Class]]或[[提炼子类|Extract Subclass]]将相关联的变量分离到新类。比如某几个变量仅被某几个方法使用，这就是提取的信号。
> - 如果拥有太多代码，最好先来确认客户端是如何使用它们的，然后利用[[提炼接口|Extract Interface]]来为每一种使用的方式提炼接口，让你看清如何分解类。
> - 如果是一个**GUI**类，你可能需要将数据移动到一个单独的对象里并保持同步。此时可以考虑使用[[复制被监视数据|Duplicate Observed Data]]。

## 过长参数列表

^Long-Parameter-List

太长的参数列表会导致难以理解，太多参数会导致前后不一致，不易使用，而且一旦你需要更多数据，你就不得不修改它。所以将对象传递给函数可能是更好的选择。

> [!summary] 相关重构手段
> - 如果向已有的对象发出一条请求就可以取代一个参数，那么你应该使用[[以函数取代参数|Replace Parameter with Methods]]。
> - 如果函数内的几个参数同属于一个对象，那么考虑使用[[保持对象完整|Preserve Whole Object]]。
> - 如果某些参数缺乏合理的归属，考虑使用[[引入参数对象|Introduce Parameter Object]]。

## 发散式变化

^Divergent-Change

如果某个类经常因为不同的原因在不同的方向发生变化，发散式变化就出现了。这说明了这个类承担了多个职责，不符合[[什么是面向对象#^09c465|单一职责原则]]。

> [!summary] 相关重构手段
> 找到某个特定原因造成的所有变化，然后运用[[提炼类|Extract Class]]将它们提炼到另一个类中。

## 霰弹式修改

^Shotgun-Surgery

如果你每遇到某个变化，你必须在许多不同的类中做出小的调整，此时你面临的坏味道就是霰弹式修改。此时调整代码非常容易遗漏。你应该将分散到各个地方的代码集中到一处。

> [!summary] 相关重构手段
> 运用[[搬移字段|Move Field]]和[[搬移函数|Move Method]]把所有需要修改的代码放到同一类。如果没有合适的类来存放就创造一个。通常可以用[[将类内联化|Inline Class]]把一系列相关行为放到一个类中。

> [!hint]
> 同[[📚大纲（重构）#^Divergent-Change|发散式变化]]一样，你都希望让外界变化与需要修改的类**一一对应**。

## 依恋情结

^Feature-Envy

面向对象的全部要点在于，**将数据和数据的行为包装在一起**。如果你发现某个函数总是对其他类的数据更感兴趣，那么你应该调整结构让函数去它喜欢的地方。

> [!summary] 相关重构手段
> - 最简单的情况是用[[搬移函数|Move Method]]。
> - 如果函数的一部分受这种依恋之苦，那么先[[提炼函数|Extract Method]]，然后再[[搬移函数|Move Method]]。

> [!hint]
> [[策略模式]]和[[读书笔记/设计模式/观察者模式|观察者模式]]破坏了这个规则，这是因为这两个模式是为了对抗[[📚大纲（重构）#^Divergent-Change|发散式变化]]。

## 数据泥团

^Data-Clumps

一些总是一起出现的数据应该拥有一个属于它们的对象。一个简单的标准就是：如果你删除了这些数据中的一项会导致其他数据不再有意义，那么你应该为它们创建一个新的对象。

> [!summary] 相关重构手段
> - 运用[[提炼类|Extract Class]]将它们放到一个对立对象中。
> - 将使用到这些参数的函数签名运用[[引入参数对象|Introduce Parameter Object]]或[[保持对象完整|Preserve Whole Object]]来为它们减肥。

## 基本类型偏执

^Primitive-Obsession

积极拥抱面向对象，即便是一些小任务上也要积极的对其建模，将其改为对象，而不是用基本类型来表示。

> [!summary] 相关重构手段
> - 运用[[以对象取代数据值|Replace Data Value with Object]]将单独存在的数据值替换为对象。
> - 对不影响行为的数值类型码可以用[[以类取代类型码|Replace Type Code with Class]]来替换。
> - 如果类型码有相关的条件表达式，则可采用[[以子类取代类型码|Replace Type Code with Subclasses]]或[[以状态或策略取代类型码|Replace Type Code with State/Strategy]]来处理。
> - 如果有一组总是在一起的字段，使用[[提炼类|Extract Class]]提取到一起。
> - 如果在参数列表中看到基本型数据，考虑[[引入参数对象|Introduce Parameter Object]]。
> - 如果在数组中挑选数据，考虑使用[[以对象取代数组|Replace Array with Object]]。

## 过多switch

^Switch-Statements

`switch`语句的主要问题在于重复，你会发现同样的`switch`语句分散在不同的地点。如果你要为其增加一个新的`case`，那么必须修改所有地方。(`if`同理)

> [!summary] 相关重构手段
> - 如果`switch`代表了要根据类型码进行选择，那么首先利用[[提炼函数|Extract Method]]将其提炼到独立函数中，再以[[搬移函数|Move Method]]将其搬运到需要多态的那个类。接下来考虑是否使用[[以子类取代类型码|Replace Type Code with Subclasses]]，[[以状态或策略取代类型码|Replace Type Code with State/Strategy]]。最后运用[[以多态取代条件表达式|Replace Conditional with Polymorphism]]。
> - 如果只是单一函数中有些选择，这种情况下[[以明确函数取代参数|Replace Parameter with Explicit Methods]]是个好的选择，如果条件中有`null`，可以试试[[引入空对象|Introduce Null Object]]。

## 平行继承体系

^Parallel-Inheritance-Hierarchies

这是[[📚大纲（重构）#^Shotgun-Surgery|霰弹式修改]]的特殊情况。表现为你为某个类增加一个子类，就必须为另一个类也相应的增加一个子类。

> [!summary] 相关重构手段
> 让一个继承体系的实例引用另一个继承体系的实例。如果再接再厉运用[[搬移字段|Move Field]]和[[搬移函数|Move Method]]，就可以将引用端的继承体系消弭于无形。

## 冗余类

^Lazy-Class

你所创建的每一个类，都必须有实际的价值。理解维护它们都是需要付出代价的。如果一个类没做足够的工作，请移除它们。

> [!summary] 相关重构手段
> 如果子类没做足够的工作，使用[[折叠继承体系|Collapse Hierarchy]]。对于几乎没用的类，使用[[将类内联化|Inline Class]]。

## 无用假设

^Speculative-Generality

当你在想，总有某一天我要做这个事，并因此以各种各样的形式来处理非必要的事情，这种坏味道就出现了。记住一句话，如果用不到，那就去掉。

> [!summary] 相关重构手段
> - 如果某个抽象类没有太大作用，那么使用[[折叠继承体系|Collapse Hierarchy]]。
> - 不必要的委托用[[将类内联化|Inline Class]]清除掉。
> - 如果函数的某些参数没用上，使用[[移除参数|Remove Parameter]]。
> - 如果函数名称带有多余的抽象意味，那么用[[函数改名|Rename Method]]让它现实一些。

## 令人迷惑的暂时字段

^Temporary-Field

有时你会看到某个实例变量只为某种特定情况而设。这样的代码让人难以理解。在变量未使用的情况下猜测其目的，会让人发疯。

> [!summary] 相关重构手段
> - 使用[[提炼类|Extract Class]]给变量安排一个新家。
> - 或许可以使用[[引入空对象|Introduce Null Object]]来引入空对象，避免变量无效时写出条件式代码。

## 过度耦合的消息链

^Message-Chains

如果你看到一个对象请求另一个对象，然后再向后者请求另一个对象，然后继续请求。这就是消息链。采取这种方式会导致客户代码与导航结构紧密耦合。

> [!summary] 相关重构手段
> - 使用[[隐藏委托关系|Hide Delegate]]来隐藏委托关系。
> - 更好的选择是先观察消息链最终得到的对象用来做什么，看看能不能用[[提炼函数|Extract Method]]将其提炼到一个独立的函数中，在运用[[搬移函数|Move Method]]将其推入消息链。

##  中间人

^Middle-Man

封装往往伴随着委托，但人们可能过度运用委托。当你看到某个类接口有一般的函数都委托给其他类，这就是过度运用。

> [!summary] 相关重构手段
> - 使用[[移除中间人|Remove Middle Man]]移除委托，和直接负责的对象打交道。
> - 如果只有少数几个委托函数，考虑使用[[内联函数|Inline Method]]把它们放入调用端。
> - 如果中间人还有其他行为，可以运用[[以继承取代委托|Replace Delegation with Inheritance]]让其变成具有实际功能的子类。

# 重构手法目录

```dataview
LIST
FROM "读书笔记/重构"
WHERE !outline
```