---
tags:
  - reference
design_pattern: Strategy
category: 行为型模式
---
> [!summary] 意图
> 定义一系列算法，把它们一个个封装起来，并使它们可以相互转换。本模式使得算法可以独立于它们的客户而变化。

> [!summary] 适用性
> 在以下情况下可以使用：
> - 许多相关的类仅仅是行为有差别。
> - 需要使用一个算法的不同变体。
> - 算法使用客户不能知道的数据。
> - 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。

> [!summary] 结构图
> ![[策略模式 2023-11-25 13.58.39.excalidraw]]
> `Context`将请求转发给它的`ConcreteStrategy`。

> [!summary] 效果
> 1. 消除了条件语句
> 2. 实现相同行为提供了多种选择，客户可以按需使用。
> 3. 客户必须要了解多种策略，这增加了使用的负担。

> [!tips] 实现细节
> - `Context`和`Strategy`应该如何通信：
> 	- 彻底解耦：`Context`将全部的数据发送给`Strategy`，但可能会多出很多不需要的数据。
> 	- 紧密耦合：`Strategy`持有`Context`或者在自身的方法里以之作为参数。
> - 是否提供默认策略，如果客户没有需求就直接使用默认的策略，降低了客户的使用成本。

> [!note] 相关模式
> - 策略模式一般是轻量级对象，很适合于[[读书笔记/设计模式/享元模式|享元模式]]。
