---
tags:
  - reference
  - csharp
---
# 编程习惯

此章节会提醒你将不符合C#的做法改掉，培养C#的编程习惯。

## 1. 优先使用隐式类型的局部变量

除非开发者必须看到变量的声明类型后才能正确理解代码的含义，否则你都可以优先考虑用`var`来声明局部变量。

> [!hint]
> 对于`int double long`等基础数值类型，由于转换可能会损失精度的问题，还是需要声明其类型。

## 2.  考虑使用readonly 代替 const

`const`最好用于声明那些必须在编译期确定的值，比如枚举，`switch`标签等等，偶尔声明那些不会随着版本变化的值。除此之外都应该使用更加灵活的`readonly`

> [!summary] 两者区别
> - `const`声明的是编译器常量，只能为整形或者字符串，编译为中间语言后会直接被替换为字面量。比如：
> 	```csharp
> 	const int FIVE = 5;
> 
> 	if (value == FIVE) {}
> 	// 中间语言替换为if (value == 5) {}
> 	```
>
>- `readonly`声明的是运行时常量，可以为任何类型，编译为中间语言后依然要根据引用去查找其对象，所以性能会低于`const`。
>
> 当另一个程序集引用此程序集时，另一个程序集编译时也会将`FIVE`替换为字面量。当此程序集的定义改变时，另一个程序集的`FIVE`不会跟着一起改变。而用`readonly`修饰则变化可以同步到另一个程序集而无需其重新编译。

## 3. 优先考虑is或者as运算符，尽量少用强制类型转换

面向对象编程时应该尽量避免转型操作，但如果非转不可的话，应该使用`is`和`as`操作符进行转换。一般情况下几乎总是可以写出正确的代码。

> [!example]
> ```csharp
> if (t is AType) {
>	AType a = t as AType;
> } else {
>	// ...
> }
> ```

> [!summary] 两者区别
> - `as`只会考虑运行期是否存在可行的转换，不会考虑用户定义的转换，不会做额外操作。
> - `cast`只会考虑编译期是否存在可行的转换，虽然会考虑用户的定义，但是如果情况是运行期可以转，编译期转不了，那么转换也不会生效。并且`cast`还会通过`long`转`short`这种会丢失信息的操作。

## 使用内插字符串取代string.Format()

字符串内插能以更优雅，更直观，更健壮的方式完成信息的转换，因此只使用字符串内插即可。

> [!summary] 两者区别
> - **字符串内插**通过`$"literal and {variable:format}"`的形式，使得可以直接在字符串内部编写C#表达式。完美的弥补了`String.Format()`的主要缺点，不会出现参数不匹配的问题并且容易阅读。
> - `String.Format()`必须要对生成的字符串进行验证，编译器不会验证参数和格式字符串里的参数是否匹配。并且阅读代码的人很难将参数一一对应到格式字符串里，导致其可读性交较差。

## 使用FormattableString取代专门为特定区域而写的字符串

通过`FormattableString`来承载内插生成的字符串，可以方便的利用其方法将其转换为适用于各个地区的表达形式。

> [!example] 时间的表示
> 在不同国家和地区时间的表示方法不相似，通过`FormattableString`可以按照地区转换为合适的形态。
> ```csharp
> FormattableString str = ${DateTime.Now};
> Console.WriteLine(str.ToString(new CultureInfo("zh-CN")))
> ```