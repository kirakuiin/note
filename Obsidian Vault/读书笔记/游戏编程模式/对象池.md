---
tags:
  - reference
design_pattern: Object Pool
category: 优化型模式
---
> [!quote]
   使用固定的对象池重用对象，取代单独地分配和释放对象，以此来达到提升性能和优化内存使用之目的。
   >
   定义一个可重用集合的对象池类，每个对象支持提供自身使用状态的方法。对象池初始化 时预先创建整个集合，当你向对象池请求时会返回一个未使用的对象，当对象不使用时将其置为未使用状态。

使用对象池一个比较经典的应用场景就是**粒子播放器**。

```python
class Particle(object):
	def Emit(self, lifetime):
		pass

	def IsInUse(self):
		"""是否还在使用中"""
		pass


class Pool(object):
	POOL_SIZE = 5
	def __init__(self):
		self._pool = [Particle() for _ in range(self.POOL_SIZE)]

	def CreateParticle(self):
		"""返回一个未使用的对象"""
		for obj in self._pool:
			if not obj.IsInUse():
				return obj
		else:
			return None

```

通过维护一个对象池，粒子对象的创建不需要通过内存管理，而是一次性申请一块内存自己进行管理，有效的防止了产生碎片化内存。

![[游戏编程模式 2023-10-29 15.16.05.excalidraw]]

> [!hint] 对象池使用场景
> - 你需要频繁的创建销毁对象。
> - 对象大小一致。
> - 每个对象封装着获取代价昂贵且可重用的资源，如数据库，网络连接。

> [!hint]
> 1. 使用代价
>	- 对象池会浪费一定内存，未使用的对象也会占用内存
>	- 对象池的对象由自己管理，不会被自动清理(0xdeadbeef)
> 2. 对象池已经用干时如何处理新的请求？
>	- 阻止申请，可以确保不会溢出
>	- 不创建对象
>	- 删除一个现有对象
>	- 增加对象池的大小
> 3. 如果存在许多不同大小的对象，建议创建多个不同大小的内存池，而不是使用同一个。这也是内存分配的管理模式。
> 4. 对象是否被加入对象池?
>	- 假如对象池和对象耦合
>		- 实现很简单
>		- 你可以保证对象只由对象池创建
>		- 可以避免存储一个代表"使用中"的标识位，因为对象知道自己被对象池使用，可以提供一个代表自身状态的函数
>	- 如果独立于对象池
>		- 你得到了一个通用的对象池类
>		- 外部必须有办法追踪每个对象的使用状态，最简单的方式就是使用标识位
> 5. 谁来初始化对象?
>	- 在对象池内部初始化
>		- 对象池可以完全封装对象的初始化
>		- 对象池可能要提供多种初始化函数，和对象的初始化方法数量相关
>	- 在对象池外部初始化
>		- 对象池的接口会更简单
>		- 外部需要处理对象创建失败的情况

---

> [!note] 和其他模式的联系
> [[读书笔记/游戏编程模式/享元模式]]也包含对象的重用，他们的区别在于，这个是时间上的重用；而享元是空间上的重用。