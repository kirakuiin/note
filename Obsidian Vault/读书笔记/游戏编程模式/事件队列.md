---
tags:
  - reference
design_pattern: Event Queue
category: 解耦型模式
---
> [!quote]
   对消息或事件的发送和受理进行时间上的解耦。
  > 
   通过一个先进先出的队列存储一系列通知或请求，发出通知后系统会将请求置入队列并立即返回，随后处理器从事件队列获取感兴趣的事件并处理这些请求。这一过程将使消息的发送者和受理者解耦，使得对消息的处理变得动态且非实时。

使用事件队列的一个经典场景是**音效播放管理**。

```python
class PlayInfo(object):
	SoundID = 0
	Volume = 0

class AudioManager(object):

	def __init__(self):
		self._pending = []
		
	def PlaySound(id, volume):
		_pending.append(PlayInfo(id, volume))

	def Update():
		if _pending:
			info = _pending.pop(0)
			channel = FindAvailableChannel()
			channel and StartPlaySound(channel, info.SoundID, info.Volume)
			
```

通常会将`AudioManager`放到一个单独的线程专门处理声音播放，通常会对这个类进行一些线程安全的处理以防发生竞争。通过事件队列，将播放声音的请求和实际播放的操作解耦，将播放声音的请求变为了一个异步接口。

![[游戏编程模式 2023-10-28 16.05.12.excalidraw]]

> [!hint] 事件队列使用情景
   当你对某个问题上在时间进行解耦时，使用事件队列。

> [!hint]
> 1. 注意事项。
>	- 事件队列一般是全局变量，全局变量一般是糟糕的
>	- 事件队列里面的消息并不是实时的，当你处理的时候很有可能环境已经发生了变化
>	- 事件处理方一般不要发送事件，这很可能导致反馈循环
> 2. 入队的是什么?
>	- 如果是事件(描述已经发生的事情，类似异步的观察者)
>		- 你会允许多个监听器
>		- 可访问队列的域会更广
>	- 如果是消息(我们希望在将来发生的行为，类似异步API)
>		- 一般只有一个监听器
> 3. 谁能从队列里读取?
>	- 单播队列
>		- 队列成为消息处理者的实现细节，封装性更好
>		- 你不必担心多个监听器竞争的情况
>	- 广播队列
>		- 事件可以被删除，如果某个时刻没有监听器，事件会被丢弃
>		- 可能需要过滤事件，监听器需要过滤收到的事件
>	- 工作队列(每个事件只会被一个监听者处理的广播队列)
>		- 需要做好规划，找到处理事件的最优监听者
> 4. 谁可以写入队列?
>	- 一个写入者
>		- 你隐式的知道事件的来源
>		- 通常允许多个读取者
>	- 多个写入者
>		- 小心反馈循环，因为任何东西都可能放入队列之中
>		- 你可能想要得到发送方的引用，事件里面可能需要存储发送方本身
> 5. 注意队列对象的生命周期。

---

> [!note] 和其他模式的联系
> 可以将事件队列理解为[[观察者模式]]的异步版本。