---
tags:
  - reference
design_pattern: Data Locality
category: 优化型模式
---
> [!quote]
   通过合理组织数据利用cpu的缓存机制来加快内存访问速度。
   >
   当代cpu带有多级缓存来提高内存访问速度，通过让数据在内存连续分布来提高速度。

使用数据局部性的一个经典场景是**冷热分解**。

```python
class AIComponent(object):
	def __init__(self):
		# 热数据，每次更新都会用到
		self._anim = Animation()
		self._pos = (0, 0)

		# 冷数据，不常用
		self._loot = LootList()

class LootList(object):
	def __init__(self):
		self.List = [1, 2, 3, 4, ]
```

通过将掉落列表存储为一个类实例的引用，减小组件的大小从而提高cpu一次能够缓存的数量，由于冷数据并不是经常使用所以也不会导致cpu访问指针导致频繁未命中。

![[游戏编程模式 2023-10-29 00.20.59.excalidraw]]

> [!hint] 数据局部性的使用场景
> 确认游戏性能的瓶颈确实是由缓存未命中引起的。

> [!hint]
> 1. 如何处理多态?
> 	为了实现局部性很可能需要牺牲一部分抽象，继承。他们的优势一般都是通过指针来实现的，但是指针跳转会导致未命中，这里需要权衡。
>	- 避开继承
>		- 安全且容易
>		- 速度更快
>		- 灵活性变差
>	- 为不同的类型对象使用互相独立的数组
>		- 这一系列的集合能够让对象紧密排列
>		- 你可以静态的进行调用分发
>		- 你必须时刻追踪这些集合
>		- 你必须维护每一种类型，无法解耦
>	- 使用指针集合
>		- 灵活性高，可扩展
>		- 对缓存不友好
> 1. 游戏的实体如何定义
>	- 通过类的指针来索引组件
>		- 你可以将组件存储于相邻的数组中
>		- 对于给定的实体，你可以很轻松的通过指针访问组件
>		- 在内存中移动很困难
>	- 假如游戏实体通过id索引其组件
>		- 更加复杂且更加缓慢
>		- 你需要组件管理器，以便通过id查找组件
>	- 假如游戏实体本身就是id
>		- 你的游戏实体类完全消失，完全依赖于组件模式
>		- 你无需管理其生命周期
>		- 检索一个实体的所有组件会很慢

---

> [!note] 和其他模式的联系
[[组件模式]]是实现数据局部性最常用的方法。