---
tags:
  - reference
design_pattern: Type Object
category: 行为型模式
---
> [!quote]
   通过创建一个类来支持新类型的灵活创建，其每个实例都代表不同的对象类型。
   >
   定义一个类型对象和一个持有类型对象的类，每个类型对象实例表示一个不同的逻辑类型，每个持有类型对象的类引用一个描述其类型的类型对象。
   
使用类型对象的一个经典场景是**怪物生成系统**。

```python
class Attr(object):
	def __init__(self):
		self.Attack = 10
		self.HP = 10
		# ... other attr

class Species(object):
	"""种类就是怪物的模板，每一个种类的实例都存储了一种怪物的属性"""
	def __init__(self, parent=None, attr=None):
		self._parent = parent
		if self._parent:
			self._attr = attr or parent.GetAttr()
		else:
			self._attr = attr or Attr()

	def GetAtk(self):
		return self._attr.Attack

	def SpawnMonster(self):
		return Monster(self)


class Monster(object):
	"""一个具体的怪物"""
	def __init__(self, species):
		self._species = species

	def GetAtk(self):
		return self._species.GetAtk()
```

每一个**Species**的实例都是一个新的怪物类型，只需要两个类就可以创造无限的怪物体系，并且实例可以在运行时动态创建，修改数据无需重新编译。模拟的单继承也可以实现怪物类型的继承结构。

![[游戏编程模式 2023-10-27 22.36.07.excalidraw]]

> [!hint] 类型对象的使用场景
> 当你需要定义一系列不同种类的东西，却又不想将它们硬编码，尤其是以下条件成立时：
> - 你不知道将来会有什么类型。
> - 你需要在不重新编译的情况下，修改或添加新的类型。

---

> [!hint]
> 1. 使用的时候要注意两点：
>	- 确保类型实例存在
>	- 类型对象处理数据比较容易，处理行为比较困难，可以通过以下方法：
>		- 创建一个预定义的行为集合，在每个类型里面持有可以访问行为的对象。
>		- 采用数据来定义行为，比如[[解释器模式]]或者[[字节码]]来定义行为。
> 2. 类型对象应该封装还是暴露?
>	- 如果类型被封装在持有对象里
>		- 类型对象变为了实现细节，降低了代码复杂度。
>		- 持有对象可以选择性的重写部分类型对象的行为。
>		- 需要给类型对象所有暴露的接口提供转发函数。
>	- 如果类型对象被持有对象公开
>		- 外部对象可以通过怪物实例即可访问类型对象。
>		- 将窄接口变宽了，降低了维护性，提高了复杂度。
> 3. 持有对象里的类型是否运行时可变?
>	- 类型不变
>		- 编码和理解起来都更简单，更加容易调试
>	- 类型可变
>		- 减少了对象的创建次数
>		- 在切换类型时要注意约束对象的状态

 --- 

> [!note] 和其他模式的联系
>- 和[[读书笔记/游戏编程模式/原型模式]]的共同点在于它们都用来处理如何在不同对象之间共享数据。
>- 和[[读书笔记/游戏编程模式/享元模式]]的区别在于，享元模式着重于节省内存，而此模式在于组织性和灵活性。
>- 和[[读书笔记/游戏编程模式/状态模式]]都把部分工作交给另一个代理对象。