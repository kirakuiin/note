这里讨论关于图形学工作原理的基础和永恒的准则，而不是那些基于近似和权衡的策略。

我们已经知道渲染的最终目标是将比特图的每一个像素着色，这个比特图通常叫做**帧缓冲**。那么最基本的问题就是**如何确定每个像素的颜色？**。

在自然界中我们看到的是光，光在环境中反弹最终进入眼睛，这个过程非常复杂。忽略大量细节，渲染系统必须计算每个像素摄像机方向最近的光是什么颜色的，有两种情况：
- 我们在直视光源，颜色就是光源的颜色；
- 光从其他方向入射，经过一次或多次反弹进入我们的眼睛。

因此我们把这个基本问题分解为两个任务，这两个任务也被称为渲染算法：
- 确定可见表面：在当前像素对应的方向上找到最近可视表面。
- 光照：确定该表面向眼睛发射/反射的光线。

# 确定可见表面

目前主要有两种策略：
## 光线追踪

不再考虑沿着由发光物体发射的方向来追踪光线，而是反过来，仅处理由眼部向像素中心的方向发射的光线，并得到第一个和其相交的物体。

伪代码：
```python
for x, y in screen_pixel:
	ray = get_ray_for_pixel(x, y)

	obj = ray_intersect_scene(ray)

	if obj:
		color = shade_point(x, y, obj)
		write_frame_buffer(x, y, color)
	else:
		write_frame_buffer(x, y, background_color)
```
## 深度缓冲

每一个像素不仅存储着颜色值，还存储着一个深度值，它记录了光会进入到眼睛中的表面距离眼睛的距离。

通过一个名为光栅化的过程，我们可以将一个表面映射到一个像素上，这个叫做源片段。我们计算这个片段的深度值，并和这个像素之前的片段，也叫目标片段进行深度比较。
- 如果源深度大于目标片段，则证明这个表面被目标片段代表的表面遮挡住了，直接丢弃。
- 如果源深度小于目标片段，则证明源片段更加靠前，更新深度值。
### 前向渲染

在每次更新深度值的时候，同时计算颜色并写入缓冲，这个叫做**前向渲染**。

```python
fill_frame_buffer(background_color)
fill_depth_buffer(INF)

// 处理场景中所有的几何对象
for obj in geo_primitive:
	// 处理对象光栅化的所有像素
	for x, y in rasterize(obj):
		cur_depth = get_depth_at_pixel(obj, x, y)
		if cur_depth > read_depth_from_buffer(x, y):
			continue
		else:
			color = shade_point(x, y, obj)
			write_frame_buffer(x, y, color)
			write_depth_buffer(x, y, cur_depth)
```

### 延迟渲染

每次更新深度值的时候，将对象的信息写入到一个名为*G-Buffer*的位置，此时不计算光照，等所有物体遍历结束后，根据这个缓冲统一计算光照。

```python
clear_geometry_buffer()
fill_depth_buffer(INF)

// 设置G缓冲
for obj in geo_primitive:
	for x, y in rasterize(obj):
		cur_depth = get_depth_at_pixel(obj, x, y)
		if cur_depth > read_depth_from_buffer(x, y):
			continue
		else:
			write_geometry_buffer(x, y, obj)
			write_depth_buffer(x, y, cur_depth)

// 计算光照
for x, y in screen_pixel:
	if read_depth_from_buffer(x, y) == INF:
		write_frame_buffer(x, y, background_color)
	else:
		obj = read_from_geometry_buffer(x, y)
		color = shade_point(x, y, obj)
		write_frame_buffer(x, y, color)
```

> [!hint] 延迟渲染的优势
> 由于硬件限制，每有一个光源就要进行渲染一次。使用延迟渲染可以使确定可见表面的过程只需要进行一次，后面只需要从*G-Buffer*中读取信息即可，这大大减少了计算消耗。
# 光照

我们知道，物体的颜色实际上是光经过物体表面反射到我们眼中光的颜色，因此物体的颜色毫无意义。我们真正的问题是光从给定方向入射，会有多少光反射到其他特定方向。所以我们的问题不是物体是什么颜色的，而是反射光是如何分布的。我们把描述这一过程的函数叫做**BRDF**[^1]，计为：
$$
f(\textbf{x}, \hat{\omega}_{in}, \hat{\omega}_{out}, \lambda)
$$
这个函数的值为一个标量，描述从$\hat{\omega}_{in}$方向，波长为$\lambda$入射光，照射到点$\textbf{x}$后反射到$\hat{\omega}_{out}$方向的相对可能性。

[^1]: bidirectional reflectance distribution function，双向反射分布函数。