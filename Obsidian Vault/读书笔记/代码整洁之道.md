---
tags:
  - reference
---
> [!summary] 代码整洁之道
> 1. 代码永远不会消失，因为代码代表着对需求最精确的约束。
> 2. 不要因为进度或是经理的要求而放松对代码质量的把控。
> 3. 良好的代码有如下特征：
>	- 短小精悍
>	- 命名规范易读
>	- 实体尽量少，依赖尽量少
>	- 能够通过测试
>	- 没有重复代码
> 4. 阅读代码的时间要远远大于修改代码的时间，所以让代码易读可以有效提高工作效率。
> 5. 随时保持代码整洁，改完后保证代码比改之前更干净。

# 有意义的命名

一个好的命名应该符合以下规则：

1. 名副其实，命名要清楚的表现它的作用，如果还需要注释证明还不够名副其实。
2. 避免误导，不要用一些带有歧义的命名，比如l和O很容易被看成1和0。
3. 做有意义的区分，`Variable`永远不应该出现在变量名中，`NameString`当然是`String`类型的，不需要加`String`。
4. 使用读的出来的名字，不要用一些奇奇怪怪的缩写和自造词。
5. 使用可搜索的名称，不要使用魔法数字，单字母的命名应该仅存在于短的局部函数中，名称长短应与其作用域成正比。
6. 避免使用编码，不必使用匈牙利命名法，不要使用m_代表私有，不要使用*I*[^1]，C来标记类。
7. 避免思维映射，明确是王道，不要指望别人看到一个特殊的名字能够产生和你一样的理解。
8. 类名应当是名词或名词性短语，不应当是动词。
9. 方法应该是动词或者动词短语。
10. 不要起一些特殊的名称，比如俚语或和文化密切关联的名称。
11. 每个概念对应一个词，比如读取属性都用`get`，设置都用`set`。
12. 别用双关语，比如`add`仅代表两个对象相加，如果向一个集合中加入一个对象应该使用`append`，而不是`add`。
13. 只有程序员才会读你的代码，所以尽管使用计算机科学的术语来命名吧。
14. 如果无法采用计算机科学术语命名，那么就采用涉及问题领域的名称，这样至少可以请教此领域的专家名称的含义。
15. 添加有意义的语境，任何变量都不可能自解释，他至少需要一个上下文来表明的他的作用。可以将一些变量放到一个命名良好的类或者命名空间中，这样可以明确表明变量的作用。
16. 不要添加没有意义的语境，只要短名称足够清晰，短的一定要比长的要好，比如说一个类叫做`GSD`，那他的方法叫`GSD_FOO`显然就不是一个好做法，因为这个`GSD`和当前语境毫无关系。
17. 碰到可以改的名字尽量优化，不要让不好的名字阻碍你前进的步伐。

# 函数

函数的编写应该遵循以下规则：

1. **短小**：函数最长20行，每行不超过150个字符。`if else while`等结构中的语句体应该只有一行并且是一句函数调用，这样可以使整个结构更加清晰。
> [!example]
> ```python
> def foo():
> 	if (sth):
> 		do_sth()
> ```
2. **只做一件事**：函数应该做一件事，符合[[什么是面向对象#^single-responsibility-principle|单一职责原则]]。
	- 一个函数内部的所有逻辑应该都唯一并处于*同一抽象层次*[^2]。
	- 判断一个函数是否只做了一件事，可以看看是否能够拆出一个新的函数，并且该函数不是仅仅重新复写了此函数。
3. **每个函数一个抽象层级**：函数中的语句都要位于*同一抽象层级*[^2]上，最好函数的阅读要符合*TO原则*[^3]，这样阅读代码就可以自顶向下逐步阅读。
4. **少用switch**：最好仅用于[[工厂方法模式]]的工厂函数的分发多态，并且隐藏在细节中。当然有时候可能也要违反这个规则。
5. **长而具有描述性的名称，远远比短而令人费解的名称要好**：当然短而明确最好。
6. **函数参数**：最好没参数，其次是一个(一元)和两个(二元)参数，最好避免三个及以上参数。
   - 单参数要么是代表根据传入的内容返回一个内容，要么代表根据传入的参数修改状态。
   - 绝对不要向参数传入标识参数(`bool`)，应该拆为两个函数。
   > [!example]
> ```python
>    def do(isA: bool):
> 	   """不要这种函数"""
> 	   pass
> 
>    # 用下面的替代
>    def doA():
> 	   pass
>    def doNotA():
> 	   pass
> ```
   - 尽量将二元函数转换为一元函数。
   - 如果函数有三个及以上的参数，说明其中一些的参数应该封装成一个类，他们应该是同属于一个更高层概念的一部分。
7. **尽量避免使用输出参数**：如果可以的话，将其改为直接在函数内部修改输出对象的状态。
7. **无副作用**：如果函数存在副作用，那么在命名时一定要体现出来。
8. **区分操作和询问**：一个函数要么回答某个问题，要么做一件事，不要既回答问题又做事。
9. **使用异常来代替错误码**：
   - 将异常捕捉和业务逻辑分离。
   - 存在异常处理的函数第一句应该就是`try`，并且整个函数只做异常处理这一件事。
   > [!example]
> ```python
> def foo():
> 	try:
> 	   dosomething()
> 	except:
> 	   pass
> 
> def dosomething():
>    pass
> ```
10. **不要有重复代码**：当出现的时候，将重复的代码抽离作为一个新的模块。**重复就是软件工程的万恶之源**。
11. **如果函数结构很长，那么最好遵循结构化原则**：即每个函数内部只能有一个`return`，循环中不要有`break`，`continue`。永远不要用`goto`，但对于小函数不需要遵循这些规则。
12. **永远不要一开始就打算写出完美的函数**：先写出能够实现功能的函数，然后再测试用例的辅助下，在维护函数功能稳定的同时，消除冗余，修改名称，拆分函数，重新安置方法位置，最后重新组装。编程艺术是语言设计的艺术，永远不要忘记我们真正的目标在于讲述系统的故事，而我们把编写的函数干净利落的拼装到一起，帮我们描述这个故事。

# 注释

> [!quote]
> 什么也比不上放置良好的注释来的有用，什么也不会比陈旧，提供错误信息的注释更有破坏性。注释总是一种失败，当你能用代码表明你的想法时，永远不要添加注释。因为注释会撒谎，而代码不会。

1. 注释不能美化糟糕的代码，与其花时间为糟糕的代码添加注释，不如将花时间清洁那些代码，把代码弄干净。
2. 用代码来阐述，与其使用注释，不如使用命名得当的函数来描述你的功能 。
3. 注释一定要和它所注释的内容在一起，它所描述的内容一定是附近能看到的，信息不要太多，简明扼要即可。
4. 注释本身就是用来解释不能自解释的代码的，如果注释本身还需要解释，那这个注释就是不合理的。
5. 短函数不需要注释，起个好名字更加重要。

> [!summary] 好的注释
> - **法律信息**
> - **提供信息的注释**：比如返回值，函数说明。
> - **对意图的注释**：解释这样做的原因(不是你实现的具体逻辑)。
> - **阐释**：当将某些晦涩难明的参数和返回值翻译为某种可读的形式。
> - **警示**：警告其他程序员某个操作的代价和后果。
> - **TODO**：有时因为某些原因将某些该做但是没法做的任务作为注释留在代码中，提示其他人需要做某事。但是要注意如果TODO过期应该及时删除。
> - **解释非常规做法**：当某个代码看起来不太合理，这个时候需要注释来诠释反常规的原因。
> - **公共API**：这种代码一般需要提供注释。

> [!summary] 坏的注释
> - **喃喃自语**：不要写别人看不懂的注释。
> - **多余的注释**：不要解释代码的实现逻辑，这样的二手信息毫无意义。如果函数名和变量名能解释清楚就不要注释。
> - **误导性注释**：如果注释是错的，依赖这个注释编程的程序员可能会陷入灾难。
> - **循规式注释**：所谓的每个函数都要有注释的规矩是愚蠢可笑的，只会把你的代码搞乱。
> - **日志式注释**：存在版本控制系统之后这种日志式可以全部删除掉了。
> - **废话注释**：不要写没有意义的废话作为注释。
> - **位置标记注释**：不要在各种闭合的结构后面加注释表明闭合结束。
> - **归属信息注释**：这种信息应当保存在版本控制系统里面。
> - **废弃注释**：代码不用不要注释，直接删除会更好，现在都使用版本控制系统，不会丢失代码。
> - **HTML注释**：使用工具来翻译出HTML注释。

# 格式

> [!quote]
> 格式比实现功能的代码本身还要重要，随着无数的版本更迭，你的代码早已可能消失不见，但是格式会一直影响着未来的开发。

> [!summary] 垂直格式
>- 源代码文件行数应该尽可能控制在500行内，总的来说越短越容易理解。
>- 源代码的名称应该简单而一目了然，第一段是大纲阐述高层次概念，细节逐步展开。
>- 使用空行来区分独立的逻辑区段。
>- 关联的逻辑行应该靠在一起，不要用空行分开。
>- 关系密切的概念应该相互靠近，不应该放到不同的文件之中。
>- 变量的声明应该尽可能靠近其使用的位置。
>- 实体变量应该在固定的位置声明(顶部或者底部)。
>- 如果一个函数调用了另一个函数，那么应该把它们放到一起，调用者在上。
>- 如果一组代码概念相关，比如说都用来测试某个东西，虽然他们测试的是不同的角度，它们也应该放到一起，因为它们有极强的概念相关性，这时候互相调用是第二位的。

> [!summary] 水平格式
> - 尽可能保持短小，最多不要超过120。
> - 使用空格分隔相关性较弱的概念，也可以用来强调运算符的优先级。
> - 严格遵循缩进规则，即便是单行的if，while也要使用缩进结构。
> - 循环或者判断中内容为空也要保持缩进。
> - 不要使用水平对齐，这是在强调其实不重要的东西。
> > [!example]
> > ```python
> > # wrong
> > one    = 1
> > eleven = 11
> > # right
> > one = 1
> > eleven = 11
> > ```

> [!warning]
> 如果团队订下了编码规范，那么一定要遵循它，这一点比其他所有格式规则都重要。一个好的软件系统是由一系列风格类似的文件构成的。

# 对象和数据结构

## 数据抽象

使用赋值器和取值器并非在变量上放置一个函数层那么简单，它隐藏了实现，关乎抽象。
   > [!example]
> ```python
>      class Point(object):
>          def __init__(self，x，y):
>              self.x = x
>              self.y = y
>      
>      class AbstractPoint(object):
>          def getX():
>              pass
>          def getY():
>              pass
>          def setCartesian(x，y):
>              pass
>          def SetPolar(r，theta):
>              pass
> ```
   第二个代码中你无法确定坐标系到底是极坐标还是笛卡尔坐标，但是它提供了一套存取结构，隐藏了具体实现而暴露接口，这个就是抽象。
   
## 数据和对象的反对称性

面向过程和面向对象具有反对称性，面向过程添加新的类型需要修改所有函数，但添加函数不需要修改已经存在的类型。而面向对象通过多态可以灵活的添加新的类型而不需要修改已存在的类型，但是添加新的函数需要修改所有的类。

> [!example]
> ```python
>      # 面向过程
>      class Circle(object):
>          def __init__(self，radius):
>              self.radius = radius
>      
>      class Rectangle(object):
>          def __init__(self，height，width):
>              self.w = width
>              self.h = height
>      
>      class Geometry(object):
>          def area(obj):
>              if isinstance(obj，Circle):
>                  return obj.radius**2 * 3.14
>              if isinstance(obj，Rectangle):
>                  return obj.w * obj.h
>      
>      # 面向对象
>      class Shape(object):
>          def area():
>              pass
>      
>      class Circle(Shape):
>          def area():
>              pass
>      
>      class Rectangle(Shape):
>          def area():
>              pass
> ```

对于所有面向对象很困难的事情，对于面向对象都是很简单的，反之亦然，这是它们反对称性的体现。所以**一切都是对象只是个传说**，有些时候你可能真的需要在一些简单地结构上做一些过程式的操作。
   
## 迪米特法则

[[什么是面向对象#^Law-of-Demeter|迪米特法则]]简单来说就是只跟直接朋友谈话，不跟陌生人谈话。换言之，方法不应该调用由任何函数返回的对象的方法。所以：

- **不要写火车代码**，比如`a.b().c().d()`，如果`b`，`c`，`d`都是方法，这种写法明显违反了定律，如果不是方法而是数据结构，没有任何行为，这样就不违反定律。为了避免这种情况，可以让`a.d()`封装好`b().c().d()`的行为，这样就不会违反定律。
- **不要混淆数据结构和对象**，一个类型要么是数据结构(没有任何行为)，要么是对象(封装)。如果既有复杂的行为，又有公共变量，这明显是没有想清楚这个类型是否需要函数的保护。

## 数据传输对象

最为精炼的数据结构是只有公共变量没有函数的类，这种类型一般用于数据传输中，有两种变形结构：

- **bean式**：以对象的形式包装这个数据结构，提供读取/存取器，实际上没什么作用。
- **active record**：在bean式的基础上提供了浏览的方法，注意，千万不要在这里面加入和业务逻辑相关的函数，这导致了数据结构和对象的混合。

# 错误处理

1. 使用异常而不是返回码。
2. 编写可能抛出异常的代码时，先写`try-except-finally`语句，通过TDD[^4]来缩小try的范围和提高`except`的准确度。
3. 抛出异常时应该给出异常发生的详细原因。
4. 在需要时定义异常包装类，所谓的异常包装类时指对一个可能抛出异常的行为进行包装，无论它内部会抛出多少种异常都在内部处理，并抛出自定义的异常。
> [!example]
> ```python
>      class MyException(Exception):
>          pass
>      
>      class ExceptionWrapper(object):
>          def open(): # 封装之后可以随意替换内部实现而不用担心影响外部
>              try:
>                  # some operation
>                  pass
>              except TypeError as e:
>                  raise MyException(e)
>              except RuntimeError as e:
>                  raise MyException(e)
>      
> 	 # 主代码
>      sth = ExceptionWrapper()
>      try:
>          sth.open()
>      except MyException as e:  # 可以有效减少异常处理的代码
>          # some handle
> ```
5. 有些时候可以将异常的情况封装为一个特殊类来处理特例，这样客户代码就不需要处理异常行为了。
6. 返回值不要为None，应该抛出异常或者创建一个特例对象来处理。
7. 函数传参不要传入None，极容易导致异常。
8. 将错误处理代码隔离于主逻辑之外，就能得到简洁且健壮的代码。

# 边界

1. 使用第三方代码时，可以用自己的类将第三方代码的使用细节隐藏，分隔边界以方便灵活修改第三方库。
2. 学习型测试指的是对第三方包编写测试代码来逐步进行功能测试(不是生产环境)，在测试的过程中学习第三方包的功能，使用学习性测试可以确保第三方程序包按照我们想要的方式工作。
3. 对于还不存在的代码，可以先根据客户代码的需求定义一个接口，并依据这个接口进行编码，当第三方代码不存在的此功能时，可以通过[[适配器模式]]将此功能转换为定义的接口的形式，并将和这段代码的交互功能全部封装到适配器中。
4. 无论是使用类包装第三方代码限制功能还是使用适配器，都会使两个实体的交互更加整洁，两边进行自由变化的时候只需要修改中间层即可。

# 单元测试

1. TDD[^4]三定律：
	- 在编写不能通过的单元测试前，不可编写生产代码。
	- 只编写**刚好无法通过**的单元测试，不能编译也算不通过。
	- 只编写刚好足以通过当前失败测试的生产代码。
1. 正是单元测试使得我们的代码可维护，可开发，可修改。无论架构有多好，如果没有测试，每次改变都有可能带来未知的bug。正因为如此，保持测试代码的整洁性和可读性是非常重要的。
	- 每个测试用例要符合**BUILD-OPERATE-CHECK**模式，即先构造，然后操作，然后测试操作结果是否正确。
	- 测试环境和生产环境是不同的，有些在生产环境无法的操作可以在测试环境下操作。
	- 每个测试用例的断言要尽可能少，每个测试用例只测试一个概念。
> [!example]
> ```python
>      def testSth():
>          obj = makeSth()
>          obj.doSmt()
>          assert obj.isOk() is True
> ```

> [!hint] 刚好无法通过
> 这个指的应该是仅有一个错误导致其无法通过，而不是多个错误。

> [!summary] F.I.R.S.T原则
>   - 测试应该是快速的(*fast*)，如果速度慢，测试就不频繁，就没法快速发现问题。
>   - 每个测试之间应该是相互独立的(*independent*)，相互之间不应该干扰。
>   - 可重复的(*repeatable*)，测试应该可以在任何环境下重复并且结果一致。
>   - 自足验证(*self-validating*)，测试应该有bool输出，通过看结果直接判断是否通过了测试，而不是查看日志或者是手工对比。
>   - 及时(*timely*)，测试要及时编写。
   
# 类

1. 如果能的话，优先保证类的封装。
2. 类应该短小，不是以代码行数衡量类的大小，而是以类的权责来衡量，符合[[什么是面向对象#^single-responsibility-principle|单一职责原则]]。有一个衡量的方法，就是它的功能可以在25个单词之内描述出来，并且没有并且，但，如果，与等单词，也没有管理器，处理器这种单词。
	- 在实际工作中可以先让代码工作，但正确工作会后一定要合理拆分为多个不同的类确保单一职权。
	- 内聚，类应该只有少量实体变量。

> [!hint] 面向对象类的设计
> 参考文档[[什么是面向对象]]。

# 系统
1. 软件系统应该将启动过程和运行时的逻辑分离，使用一个main模块构造所有对象，然后运
   行时可以假定所有的模块已经构造好了
   - 依赖注入
   - 工厂函数
2. 一开始就完整的设计好系统是不可能的，我们应该只去实现今天的用户故事，然后重构，
   明天再扩展系统，实现新的用户故事. 与物理系统相比，由于软件系统较短的生命周期，
   使得架构可以动态增长，只要我们在设计的时候将系统合适的切分
3. 测试驱动系统架构，没有必要先做大设计(Big Design Up Front)，因为人们在心理上
   抵触丢弃既成之事. 与建筑不同，建筑一点设计好就无法做出根本性的改变，而软件不同
   软件是一个快速变化的系统，可以对系统结构做出根本性的修改.
   所以最佳的软件系统架构是由模块化和关注面领域构成，每个关注面都用对象实现，不同
   的领域用最不具有侵害性的方式整合到一起
4. 决策不要太早，因为最后时刻决策拥有的信息是最多的，可以做出最正确的决定
5. 系统需要特定领域的语言(DSL)，这个可以填平领域概念和实现概念代码之间的壕沟
6. 无论是系统还是模块的设计，别忘了使用大概可工作的最简单方案

# 迭进
1. 简单设计的四条原则(重要程度由上到下):
   - 运行所有测试
   - 不可重复
   - 表达了程序员意图
   - 尽可能减少类和方法的数量
2. 测试消除了清理代码就会破坏代码的恐惧
3. 哪怕存在很短小的代码重复也要将其抽成一个短小的接口，这时如果违反了SRP原则，则
   应该添加一个新的类
4. 一定要让代码有表达力，准确的命名，良好的测试. 最重要的方法就是多尝试，觉得有问
   题及时调整代码，毕竟下一个阅读这段代码的人最可能的就是自己
5. 类和方法的数量要尽可能少，不过要在满足前三条的情况下在考虑这个问题

# 并发
并发是一种解耦策略，将我们把做什么(目的)和何时做(时机)分解，在单线程里面，目的和
时机紧密关联. 通过解耦目的和时机能有效改进应用程序吞吐量和结构
1. 迷思与误解
   - 并发总能改进性能 :: 只能在只在多个线程之间能分享大量等待的时候改进
   - 编写并发程序无需修改设计 :: 目的与时机的解耦往往对系统结构有巨大影响
   - 采用一些库的时候理解并发并不重要 :: 实际上你最好了解你在做什么
   - 并发会在性能和编码上增加一些开销
   - 正确的并发总是复杂的，即便对简单地问题也是如此
   - 并发缺陷并非总能重现
   - 并发常常需要对设计策略进行根本性的修改
2. 并发防御原则
   - 单一职权原则 :: 分离并发代码和其他代码
   - 限制数据作用域 :: 严格封装，限制对可能被共享的数据的访问
   - 是用数据复本 :: 避免数据共享的最好方式就是避免共享
   - 线程独立 :: 让每个线程都是用自己的数据，不和其他线程共享，避免了同步的复杂性
3. 常用执行模型
   #+NAME: 模型表
   | 名称     | 基础定义                                                         |
   |----------+------------------------------------------------------------------|
   | 限定资源 | 并发环境中有着固定尺寸或者数量的资源，例如数据库连接             |
   | 互斥     | 每个时刻仅有一个线程能访问共享数据或者共享资源                   |
   | 线程饥饿 | 总是让执行的快的线程先运行，部分运行慢的线程就会挨饿             |
   | 死锁     | 两个或多个进程互相等待执行结束，并且拥有其他线程需要的资源       |
   | 活锁     | 执行次序一致的线程发现其他线程已经启动中导致自身很长时间无法启动 |
   1. 生产-消费者模型
      一个或多个生产线程创建某些工作，置于缓存或者队列之中，一个或者多个消费者从
      队列中获取这些工作并完成，这是限定资源模型
   2. 读者-作者模型
      当存在一个主要为读者线程提供信息源，偶尔被作者线程更新的共享资源. 这个时候
      吞吐量和更新频率会成为主要权衡的地方
   3. 宴席哲学家
      一群哲学家围坐在桌子旁，每个哲学家左手边有个叉子，每个哲学家要吃饭就必须拿
      起两个叉子，如果手上没有叉子就无法进食，所以每个哲学家必须等待左右两边的哲
      学家吃完将叉子放回后才能进食，这里哲学家就是线程，叉子就是资源.
4. 警惕同步方法之间的依赖，所以不要使用同一个共享对象的多个方法，这样就不会因为方
   法调用的顺序产生问题
5. 尽可能保持临界区短小
6. 多线程编程要尽早考虑正确关闭的问题，非常有可能存在部分线程没有正确释放导致程序
   卡死
7. 对线程代码编写能够暴露问题的测试:
   - 将伪失败看做线程问题，不要讲偶发的错误认为是系统问题
   - 先使非线程代码可以正常运行
   - 编写可调整，可插拔的线程代码
   - 运行多于处理器数量的线程
   - 在不同平台上运行
   - 调整代码并强迫错误发生

# 逐步改进
重构步骤:
1. 首先编写一个完成功能并且能够进行测试工作的艾迪玛
2. 编写单元测试和验收测试来测试代码，在这个过程中逐渐修复bug
   - 单元测试测试的是代码哪里出现了错误
   - 验收测试测试的是代码是否完成了功能
3. 测试通过后审视代码不合理的设计和实现，开始重构
4. 在保证代码能够通过测试的前提下一点点替换不合理的设计，每替换一次都测试一次，
   确保修改之后功能正确
5. 当代码经过若干此重构之后整洁之后，重构完毕，并且功能保持了正确

# 味道与启发
** 一般性问题
1. 一个源文件里面最好只存在一种语言，如果不得不使用其他语言也最好控制其数量和范围
2. 函数和类应该符合最小惊异原则，即应该实现其他程序员有理由期待的行为，如果明显的
   行为没有被实现，读者和用户就不能再依赖直觉，不得不阅读代码细节
3. 如果代码存在边界情况应该仔细测试，确保在任何条件下都能够正常工作
4. 不要忽视编译器或者编辑器给出的安全提示
5. 绝对不要重复代码，每个重复的代码都代表了缺失的抽象
   - 比较隐蔽的是在不同模块重复出现的ifelse，可以用多态来代替
   - 更加隐蔽的是采用了类似算法但是具体代码不同的模块，可以使用策略模式来修正
6. 分离高层次的一般概念和低层次的细节概念，高层次通用概念放到基类中，细节放到子类
   中，比如一个stack基类中不应该有stack的充满百分的函数(这是个低层次概念)
7. 基类不应依赖于派生类，通常来说基类应该多派生类一无所知(有些有限状态机基类和子
   类是紧密耦合的，这个不在讨论范围之内，只考虑通常情况)
8. 类中的方法越少越好，函数知道的变量越少越好，类拥有的实体变量越少越好
9. 应该及时将代码中的死代码删除(不掉用的代码，可能是永远不会达到的分支，异常等等)，
   他们会随着时间变得逐渐腐败
10. 函数和变量应该在靠近被使用的地方定义，私有函数应该在其被调用的位置后面定义
11. 代码的前后规范要保持一致
12. 不要写一些没有意义的注释，不会用到的代码来混淆视听
13. 不互相依赖的东西不应该相互耦合，比如一个通用的enum不应该放到一个特殊的类之中，
    出现这种情况大概率是为了图方便，但不应该这样，调用者不应该了解一个完全和enum
    不相干的类
14. 尽量避免特性依恋，即调用一个类的接口的接口，这相当于你已经了解了类的实现细节，
    封装失效了
15. 函数里不要有算子参数(bool，枚举，常量)，这明确的表明了你的函数做了不止一件事
    情
16. 软件开发者做出的最重要的决定就是在哪里放置代码，所有务必将代码放置到合适的位
    置上
17. 使用静态函数要确保其不会有多态行为
18. 变量的命名最好具有解释性，只要将一系列计算过程打散为命名良好的中间值，整段代
    码就会变得透明
19. 一定要了解自己的代码到底在做什么，如果不确定就重构之
20. 将逻辑依赖替换为物理依赖，依赖者模块不应改对被依赖模块有任何假定
21. 对于给定的选择类型，如果多于一个switch语句，则多余的switch语句应该以多态替代
    之，并取代系统中其他类似的switch语句
22. 每个成员都应该遵循团队的代码标准
23. 以命名常量替代魔术数，魔术数指所有不能自我描述的符号，所以需要命名常量来描述
    其含义
24. 写代码要确保其准确性，明白代码的准确作用. 比如货币使用整形而不是浮点数，如果
    调用了可能返回null的函数是否检查其返回值
25. 结构要大于约定，约定使用永远无法代替结构的强制性. 比如抽象类会强迫所有子类实
    现接口，而约定却没法强制执行
26. 将一系列逻辑判断合并为一个命名清晰的接口会让代码更加易读
27. 肯定性条件大于否定性条件
28. 每个函数应该做一件事且仅做一件事
29. 不要遮掩代码之间的时序耦合，如果函数之间的调用有顺序关系，可以将多个函数通过
    返回值和参数使他们具有明确的先后关系，即后一个函数需要前一个函数的返回值作为
    参数
30. 将边界条件封装到一处，比如一段代码里出现了多次n+1，那么应将此n+1赋值给一个
    命名清晰的变量，其他使用n+1的位置替换成这个变量
31. 每个函数中的语句都应该在同一个抽象层级上，该层级应该是函数名所示操作的下一层
32. 如果有配置性的数据，应该在较高的层次上存放，而不应该在代码的底层存放配置值
** 命名
1. 命名是对软件可读性影响最大一部分，90%的可读性由命名来决定，所以慎重命名
2. 命名应该同其抽象层级相符合
3. 命名尽可能使用标准命名法，装饰器就用decorator，代理就用delegate
4. 命名时不要带有歧义，意思一定要准确
5. 命名的长度应该和其作用域成正比
6. 避免前缀编码，比如m_，f，s等
7. 名称应该说明其副作用，比如一个函数用来获取一个对象，如果对象不存在还负责创建，
   那么它的名字应该为createOrReturnObj
** 测试
1. 测试应该覆盖到所有语句，而不是以测试的数量来判断测试是否充足
2. 使用覆盖率工具可以清晰的得到测试的覆盖率
3. 小测试易于编写，更加重要的是它是一份清晰的用法文档
4. 特别注意对边界条件的测试，90%的代码错误都出现于边界
5. 如果在某个函数中发现一个缺陷，那么最好全面测试这个函数，你可能会发现多个缺陷
6. 测试应该快速


[^1]: C#官方约定里使用'I'开头来指代接口类型。
[^2]: 比如说我要洗碗可以抽象为：找到脏碗->清洗->放置到合适位置。这三个行动就处于同一抽象层次上。清洗里还有个喷洒洗洁精的步骤，这个的层次就要低于上面的三个操作。
[^3]: 每一段函数的内部调用的都是他下一个抽象层级的函数，就像TO开头的段落一样，"To do sth, we need ..."。
[^4]: 测试驱动开发（Test-Driven Development）。