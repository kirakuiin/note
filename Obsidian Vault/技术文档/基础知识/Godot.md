---
tags:
  - reference
  - godot
---
# GDScript

## 在Inspector中显示提示

要用两个`#`号作为变量注释的开头。

```gds
## 范围
@export var range: int
```

## 让类全局可见

使用`class_name`来导出。

```gdscript
class_name YourClassName
extends Node

...
```

## 引用节点的方式

- `get_node("A/B")`：引用从脚本所在节点开始的相对路径，上层用`..`表示。
- `$A/B`，上个方式的语法糖，不过如果要表示上层路径需要用引号包围`".."`。
- `%B`：需要在编辑器中首先将节点设置为*唯一名称访问*，然后就可以直接用`%`加名称来引用，这个方式的优点在于无论节点的位置如何变动，代码里都不需要发生变化。

> [!hint]
> - `self`，`$"."`都可以用来指代自己。
> - `$".."`，`get_parent()`用来指代父节点。

## 生命周期的调用顺序

对于一个树状结构，

`_enter_tree`，使用先序遍历。
`_ready`，`_exit_tree`使用后序遍历。
# 编辑器

## AssetLib无法打开

如果你使用了代理，Godot是不会自动使用你的代理的，所以在编辑器->编辑器设置->网络->HTTP代理中设置你的代理的端口。

## 快捷在脚本中引用变量

可以直接将节点从层级结构中拖到文本编辑器内部，会直接生成对这个节点的引用。

如果按住`ctrl`在拖动，会生成`onready`标记的延迟赋值节点。

# UI

## Container中子对象的容器大小设置

- 扩展：这个代表这这个UI对象会向父容器申请多少空间，如果勾选的话就代表会向父容器点申请尽可能多的空间。
- 填充/收缩：这个代表这如何使用向父容器申请来的空间，填充就代表完全使用申请来的空间，收缩代表尽可能少的使用申请来的空间。

以上两者有严格的逻辑顺序，即：
1. 先向父容器申请空间。
2. 然后决定如何使用这个空间，这一步能使用的总空间大小取决于第一步。
## 如何让UI界面独立于游戏世界

使用`CanvasLayer`节点，UI对象至于其下。

## 如何在容器中创造间隔

创建一个简单的`Control`节点，并将其容器大小设置为扩展，然后将其置于合适的位置上。

## 如何让UI更加美观，一致

`Control`类型的节点下都有一个`theme`的属性，通过配置这个属性可以影响各种控件的表现效果。

如果你对一个父节点设置了一个`theme`，那么所有的子节点都会自动应用这个`theme`。

# 资源管理

## 创建自定义资源

类似于Unity里的ScriptObject，Godot中也提供了自己的资源管理方案，也就是资源。Godot内部中的许多对象，比如shader，UI主题，音频，动画都是一种资源。

创建自定义资源的方法是新建一个脚本，然后键入你想要保存的数据：
```gds
extends Resource

@export var name:String
@export var scene:PackedScene
```

之后在新建资源的菜单内就能看到你定义的资源类型。

> [!hint]
> 如果看不到，考虑重新加载项目。

## 资源的管理方式

可以通过下载一个叫做**Edit Resources as Table**的插件，它可以让你在一个目录下分散的资源文件向电子表格一样浏览，编辑。

## 资源用作存档

资源可以当作存储数据的存档来使用，它具有如下优点：

- 它是Godot内建的类型，Godot会自动对其内部的数据序列化和反序列化。
- 它存储的数据可读性非常好。
- 数据的存储顺序可以是任意的。
- 编译器会为你提供类型检查。

缺点主要为：
- 由于数据可读性很好，所以很容易被修改。
- 数据内可以嵌入恶意代码，导致系统不安全。
- 依旧存在兼容性的问题，加载过去的数据需要检查是否可用。

Godot中一个可扩展的存档方案可以这样设计：
- 使用Resource作为存档对象，不同的对象可以通过继承来扩展需要保存的属性。
- 通过组来标记需要存档的对象，通过`call_group`来执行对应的方法。由于GDScript不支持接口，因此只能使用这种不太可靠的方案。
- 通过`ResourceSaver`来存储存档对象。
- 存档的路径要位于`user://`路径下。