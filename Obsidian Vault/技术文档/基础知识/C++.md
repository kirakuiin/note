---
tags:
  - interview
  - cpp
---

#  c++编译过程

1. 预处理；
	 	1. 将所有的`#include`语句替换为头文件的内容；
	 	2. 将所有的宏替换为真正的内容；
	 	3. 根据条件编译决定真正需要编译的内容；
2. 编译，通过语法，词法，语义分析，优化之后将每个文件代码转化为汇编代码，即 **.s**文件；
3. 汇编，通过不同平台的汇编器将每个文件的汇编代码转为机器码，即生成可重定向的二进制文件 **.o**；此时还会生成符号表（存放函数名，变量名等等），但此时它们还没有分配有效的地址；
4. 链接；
	1. 将所有的 **.o** 文件的数据段，代码段等段进行合并，符号表也同时合并，并重新建立好映射关系；
	2. 分配虚拟地址，并将其与符号表中的符号一一对应起来，使其成为正确的地址；
	3. 链接依赖文件；
		- 静态链接，如果依赖的静态库（.a)，那么会把静态库当作一个 **.o**文件来处理，将其各种符号合并，最终生成一个可执行文件；
		- 动态链接，如果依赖的是动态库（.dll)，如果发现某个符号的定义在动态库中，那么会把符号以及动态库记录到可执行文件中，当程序开始运行时由操作系统来完成剩余的链接工作，将对动态库的调用重定向到动态库中的代码；

# 动态链接和静态链接的对比

- 静态链接：
	- 优点：
		- 执行速度快；
		- 不会因为运行时环境缺少库导致无法运行；
	- 缺点：
		- 体积大；
		- 当依赖的库改变时必须重新编译；
- 动态链接：
	- 优点：
		- 更加节省内存；
		- 只要接口不变，可以同程序源代码各自独立变化，完成了解耦；
	- 缺点：
		- 使用动态链接后程序不是完备的，如果环境内缺少动态库则无法执行；

#  c++运行时程序内存结构

在内存中分为5个区域：
![[C++ 2024-08-16 12.29.43.excalidraw]]
- 代码段：存放编译后的机器码；
- 数据段：存放显式初始化的全局变量，静态变量，常量；
- BSS段：存放未初始化的全局变量或静态变量，全部设置为0；
- 堆段：动态分配内存区，由程序员手动控制；
- 栈段：存放函数调用参数，局部变量，任务的上下文，这部分由操作系统管理；

#  多态是如何实现的？

每个具有虚函数的都包含一个虚表指针，它指向一个指针数组，指针数组内部指向了这个类的全部可调用的虚函数。类似于静态变量，一个类型共享同一个虚表，并且位于数据区。
![[C++ 2024-08-16 12.19.38.excalidraw]]
当B继承A后，B和A内部的虚表指针数组内容是一样的，当B覆写A的部分虚函数后，B的虚表指针数组会更新，用B的函数覆盖A的函数。

当使用父类型的引用或指针指向子类型的对象，并且调用虚函数时，会直接查看当前对象的虚表内部对应的虚函数，而当前对象运行时类型是子类型，所以调用的就是子类型的虚方法，由此实现了多态。

# 棱型继承的问题与解决方案

![[C++ 2024-08-16 17.30.21.excalidraw]]

主要导致的问题是：
- 冗余性：导致了空间浪费；
- 二义性：无法确定该访问B还是C的`a`；

解决的方案就是在导致问题的源头使用虚继承：
```cpp
class B : virtual public A {}
class C : virtual public A {}
class D : public B, public C {}
```

使用之后内存结构里会多出虚基表，用来存储基类数据的偏移。

> [!hint]
> 虚继承会增加大小，降低速度，初始化的复杂度也会提高。
# volatile的作用

告诉编译器对象的值可能会以未明确指示的方式法改变：
- 硬件寄存器；
- 中断服务程序；
- 多线程中主线程定义的变量；

一旦声明后，编译器不会对其进行优化，每次访问这个变量都会直接从内存中读取；

# 引用和指针的区别

引用指的是一个对象的别名，而指针实际上是一个变量，其内部存储了其他变量的地址。

它们的区别主要有以下几点：
- 引用初始化时就要赋值，而指针不用；
- 指针可以设置为空，但引用不能；
- 引用可以向变量那样直接使用，但指针不行，需要用`->`；

# 三种智能指针的功能

- **unique_ptr**：独占资源的指针，任何时候都是只有一个**unique_ptr**占有资源。它持有的资源只能转移或者被释放；
- **shared_ptr**：共享所有权的指针，即多个**shared_ptr**可以使用同一个对象，当最后一个被销毁时，释放持有的资源；
- **weak_ptr**：弱引用指针，它不会增加引用计数，主要用于防止循环引用；

> [!hint] shared_ptr的实现方式
> 本质上是一个代理，用来控制对对象的访问，其内部需要
> - 一个对象类型的指针，用来指向保存的对象；
> - 一个整形指针，用来保存引用计数，用指针来保存计数可以实现多个指针之间共享计数的功能；
> 
> 重载两个指针相关的操作符，然后在初始化，拷贝，赋值，析构等时刻维护对象和计数就可以了。

# extern "C"的作用

这句话代表着被这条语句包围的语句，都用C的方式来处理，而不是C++：
```c
// math.h
#ifdef __cplusplus
extern "C" 
{
#endif
int add(int a, int b);
int div(int a, int b);
#ifdef __cplusplus
}
#endif

// a cpp file
#include "math.h"
```

这种用法的主要用途是让C++代码可以调用C编写的文件，最主要的原因是c++由于支持重载，所以会对函数名进行名称粉碎的过程，比如一个`add`的函数如果使用c和c++的编译器，会生成不同的符号：

```C
// c++
add => __Z12add
// c
add => _add
```

当用c++的模式去链接c编写的代码时，就会出现符号`__Z12add`未定义的错误。但只要加上`extern "C"`，符号就会被解析为`_add`，这样就可以正确链接了；

> [!hint]
> 一般来说这个要搭配`__cplusplus`宏一起使用，让这个文件可以在c和c++中都能工作。

# 右值引用的作用是什么

延长**右值**[^1]的生命周期，是只可以在多个对象之间传递，避免了临时对象的拷贝和析构，增加了效率。

# 野指针和悬挂指针

野指针指的是未初始化的指针；而悬挂指针指的是指向的对象被释放，但该指针依然指向被收回的内存地址。它俩的共同点是都指向一片无效的内存区域。

为了避免出现这两种指针，最好养成以下习惯：
- 初始化时给指针设置为`nullptr`。
- 释放之后及时将其改为`nullptr`。
- 使用智能指针。

# 句柄和指针的区别

- 指针：指向内存中一块地址；
- 句柄：指向系统中某个资源的位置，而这个位置又指向了真实的物理资源，所以句柄是指针的指针；

# 指针常量和常量指针

- 指针常量，它是个指针类型的常量，也就是说它本身的值是没法改变的，但是它指向的对象的值是可以改变的；
```cpp
int a;
int * const p;
// wrong
p = &a;
// right
*p = a;
```
- 常量指针，它是个指向常量的指针，它本身的值可以改变，但是它指向的对象的值不能改变；
```cpp
int a;
const int * p;
// right
p = &a;
// wrong
*p = a;
```

# RAII 是什么

这是c++的资源管理策略，即资源获取时就初始化，在对象析构的时候则将其释放。

在进入需要使用资源的地方定义资源对象，当离开作用域时资源就会被自动释放。智能指针也是通过这个策略来管理资源的。

# static 都有什么作用

- 修饰全局函数或者变量，将会把这个定义隐藏起来，其他源文件无法看见。
- 修饰函数内的局部变量，会延长变量的生存周期，变为永久存在。
- 类内的静态成员变量为所有的类实例共享且永久存在。并且只能在类外定义。
- 类内的静态函数只能使用类的静态变量，不能使用`this`指针。

> [!hint] 匿名命名空间
> 对于隐藏源文件内的变量和定义，更推荐使用匿名命名空间。
> ```cpp
> namespace
> {
> 	// 效果等于加上了static
> 	void Func() {}
> 	int a = 1;
> }
> ```

> [!hint]
> - 全局和类内的静态变量在执行main函数之前初始化。
> - 函数内部的局部静态变量保证在使用它之前初始化。

# 四种强制转换

```cpp

// static_cast
int a = 1;
double b = static_cast<double>(a);

// const_cast
const int a = 1;
const int* p = &a;
int* q = const_cast<int*>(p);

// reinterpret_cast
int *a = new int(1);
double *d = reinterpret_cast<double*>(a);

// dynamic_cast
class Base {virtual func() {}};
class Derived : public Base {};

Base* p = new Derived();
Derived* q = dynamic_cast<Derived*>(p);
```

## static_cast

- 用于基本数据类型的转换，比如int=>double；
- 将子类指针转为父类指针；
- 将空指针转换为目标类型的空指针；
- 将任何类型的表达式转为`void`类型；

## const_cast

用于去掉常量指针或者常量引用的的`const`修饰符，去除之后可以用来修改变量。不过这种行为很危险，不推荐使用。

## reinterpret_cast

- 改变指针或者引用的类型；
- 将指针转换为整形；
- 将整形转换为指针或引用类型；

## dynamic_cast

这是唯一一个在运行时进行的转换，需要进行类型检查。它主要用于：
- 用于将带有虚函数的类型的指针安全的向上转型，此时作用等于`static_cast`；
- 用于将带有虚函数的类型的指针安全的向下转型，如果失败会返回`nullptr`；

# new, delete, malloc, free的区别

- new：开辟一片地址，调用构造函数；
- malloc：仅分配地址，返回一个无类型的指针；
- delete：调用析构函数，释放占用内存；
- free：释放占用的内存；

# 公有继承，保护继承，私有继承

- 公有继承：父类的public在子类中还是public，protected还是protected，private还是private。
	- 子类内部可以访问基类的public和protected，但不能访问private。
	- 子类对象（外部）可以访问基类的public，其他不能访问。
- 保护继承：父类的public和protected变为protected，private还是private。
	- 子类内部可以访问父类的public和protected，但不能访问private。
	- 子类对象（外部）无法访问基类的任何成员。
- 保护继承：父类的public和protected变为private，private还是private。
	- 子类内部可以访问父类的public和protected，但不能访问private。
	- 子类对象（外部）无法访问基类的任何成员。

# 静态绑定和动态绑定

所谓静态绑定，也叫做早绑定，是指它在程序中被声明时所采用的类型，这个类型在编译阶段就已经确定了。

动态绑定是指“对象目前所指的类型”，也叫做晚绑定，它可以在运行期发生变化，一般通过赋值操作来实现。

```cpp
class B {};
class D : B {};

// p的静态类型是B，动态类型是D
B* p = new D;
```

# 对象的内存结构

首先，类型对象内部有一个对齐原则，即对象的大小一定为：
$$
\min(\max(类型成员大小), \#pragma \ pack(n))
$$
比如内部最大的一个类型为8字节，而`#pragma pack(6)`，那么这个对象的大小一定是6的倍数。

内存对齐的意义是为了加速cpu的读取速度，因为cpu是按照块来读取而不是一个一个字节读取的。

> [!example]
> 假设cpu每次读取4个字节，而类型的第一个数据占4字节，并且起始位置位于第二字节，那么为了完整读取它就要读取两次，如果对齐的话一次就可以了。

下图展示了类在内存中的结构：
![[C++ 2024-08-20 00.34.10.excalidraw]]

# 构造函数抛出异常后，会导致内存泄露吗

不会，编译器会负责释放掉构造过程中已经初始化完毕的对象。

# 如何分离模板的声明与定义

模板的声明与定义必须要在同一个文件，这是由c++的单独编译导致的。当你某个文件实例化了某个具体类型的模板，编译器会根据这个类型来生成一个真正存在的类，所以需要模板的定义才能生成，单靠声明是不够的。

如果你将模板的声明和实现相分离，那么：
1. 模板所在的源文件编译之后什么都不会生成，因为它没有具体的类型。
2. 使用模板的源文件编译时还是可以根据声明推断出符号，期望在链接阶段得到定义，所以不会报错。
3. 到了链接阶段，由于模板的定义没有生成，所以链接错误。

所以这个叫做模板，而不是范型，范型的类型是真实存在的，而模板不是。

如果一定要分离实现的话，有两种方法：
- 头文件里`#include`实现的源文件。但这种方案实际上只是看起来好看了一些，对减少编译依赖毫无作用。
- 源文件中提前定义所有会被特化出来的类型。
	```cpp
	#include "A.h"

	template <class T>
	class A
	{
	};

	template <class T>
	T Func()
	{
	}

	// 以下两种类型会被编译器定义，链接时不会报错了。
	template class A<int>;
	template class A<double>;
	template int Func();
	```

> [!hint]
> 如果想要消除编译器的警告，可以在使用模板的位置加上
> ```cpp
> extern template class\<A\> int;
> ```

# include的规则

- `#include <>`代表：
	1. 先从编译器设置的路径中搜索。（g++ -I "xx/xx/include")
	2. 如果找不到，然后在**INCLUDE**环境变量中搜索。
- `#include ""`代表：
	1. 先从文件所在的当前目录搜索。
	2. 如果找不到，则按最近打开优先的原则从其他的`include`的文件的所在文件夹中查找。
	3. 接下来同`#include <>`相同。
# 函数调用过程

1. 开辟栈帧空间。
2. 函数参数**从右至左**[^2]入栈。
3. 返回地址入栈（也就是调用函数的下一句指令）。
4. 局部变量入栈。

如果是类成员，`this`参数也会入栈.
如果是虚函数，会先通过虚表指针查到函数的地址，然后进行调用。

> [!hint]
> 参数入栈的顺序有几种标准：
> - cdecl：
> 	- 参数从右至左；
> 	- 由调用者恢复栈堆；
> 	- 函数名前加下划线；
> - stdcall
> 	- 参数从右至左；
> 	- 由被调用者恢复栈堆；
> 	- 函数名前加下划线，后面跟@和参数大小；

# 标准库容器底层原理

`vector`底层是由一段连续的内存和三个指针来管理的。
![[C++ 2024-08-20 12.57.22.excalidraw]]

当当前大小和总大小一致时会出发扩容，扩容会：
1. 拷贝元素；
2. 释放旧空间；
3. 开辟新空间，大小为旧空间的$m$倍；
4. 将元素放到新空间中。

$m$在windows下是1.5倍，因为扩容是一个比较费时的操作，所以要设置一个合适的值，太小会导致频繁触发扩容浪费性能，太大会导致浪费空间。1.5有如下优点：
- 对于初始容量为a的m倍扩容，添加n个元素`push_back`的总调用次数为（算上扩容的拷贝）：
	$$
	\begin{align}
	&n + a + am + am^2 + ... + am^{log_m^\frac{n}{a}} \\
	&= n + a\frac{1-\frac{n}{a}}{1-m} \\
	&= \frac{a-nm}{1-m}
	\end{align}
	$$
	除以数量$n$，可得每次的开销为$\frac{n/a-m}{1-m}$，当$n \rightarrow \infty$时，开销为一个常数$\frac{m}{m-1}$。
- 如果想要第n次扩容的空间可以完美利用之前所开辟的空间，即$f(n) = f(n-1) + f(n-2)$，这样就可以减少内存碎片产生，而这个数列的增长速度就是黄金分割率$1.618$。所以取一个近似值用了$1.5$。

`stack`底层由`vector`实现。

`deque`由映射表加缓冲来实现。每个指针指向一段缓冲，数据存储在缓冲中。它给了你一种连续的假象，实际上它存储数据的内存是分段的。
![[C++ 2024-08-20 12.42.42.excalidraw]]

`map`使用红黑树实现的，红黑树是一个非严格的自平衡搜索二叉树。红黑树要满足如下性质：
- 每个节点不是黑的就是红的；
- 根节点是黑色的；
- 叶子结点是黑色的；
- 从根节点到所有叶子黑色节点数量相同；
- 红色节点的子节点是黑色的；

`unordered_map`，`unordered_set`底层使用哈希表实现的，采用链地址法来存储冲突的键。

![[C++ 2024-08-17 01.12.10.excalidraw]]

# 子类和父类的构造函数

c++中，子类会默认调用父类的无参构造函数，如果父类不存在无参的构造函数，那么必须主动调用父类的构造函数来完成初始化。

当存在多个父类构造函数时，子类如果想要全部覆盖父类的构造函数，就要一一重新实现。但是c++11引入了一个新的语法：
```cpp
class Base
{
public:
	void f();
};
class Derived : public Base
{
public:
	using Base::Base; // 引入全部构造函数
	using Base::f; // 可以用来解决子类的覆盖问题
	public void f(int);
}
```
这会直接将父类空间中指定的函数引入这个空间。

[^1]: 临时值，等号右边的值，不可以取地址。
[^2]: 由右至左的好处在于可以表达变长参数的概念。