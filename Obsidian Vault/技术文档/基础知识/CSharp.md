---
tags:
  - interview
  - csharp
---

#  C#的编译过程

1. 汇编器编译，将源代码编译成中间语言（IL）；
2. 生成程序集，将编译好的IL和元数据打包成程序集（dll或exe）；
3. 在运行时，.NET的公共语言运行时（CLR）会加载程序集，并运用其内部的编译器将其转换为本地的机器码，然后在执行；

# C#闭包概念。

闭包指的是函数引用不在其内部定义的外部变量。C#中闭包会创建一个类对象来存储引用，因此会在堆上分配内存。

# C#中的unsafe是什么？

代表未经验证的上下文。在unsafe关键字内可以使用指针，创建内存块等平时无法使用的操作。

# 值类型和引用类型的区别？

- 值类型基类是`System.ValueType`，存放在栈中，内部存储的是对象的值。
- 引用类型基类是`System.Object`，存放在堆中由GC进行释放，其内部存放的是对象的引用，即地址。

# 什么情况下会触发装箱拆箱

- 将值类型存放到`ArrayList`中会触发装箱。
- 使用上一步中存放的对象会导致拆箱。

# C# GC的流程是如何的？

GC是基于代的，引用跟踪算法回收器。
引用跟踪算法是指：
1. 遍历对中某一代的对象，将其设置为不可达；
2. 从所有的根[^1]出发，将所有可达的对象设置为可达；
3. 将所有不可达的对象回收；
4. 压缩地址，将存活对象连续排列，期间会涉及到数据拷贝，引用更新；

代是基于如下假设成立的：
- 对象越新，生命周期越短；
- 对象越老，生命周期越长；
- 回收堆的一部分速度大于回收整个堆；
所以每经历过一次GC，每被回收的对象就会被放到下一世代，世代越老，回收频率越低。

GC会在以下情况下触发：
- 空间不足。
- 显式调用GC.Collect。

# 可访问性定义

- **public**：访问不受限制
- **private**：访问仅限于此类
- **protected**：访问仅限于此类和其派生类
- **internal**：访问仅限于当前程序集
- **protected internal**：等价于**protected**或**internal**，满足任一条件即可访问
- **private protected**：等价于**protected**和**internal**，必须同时满足两个条件才能访问

![[C Sharp 知识点 2023-10-30 14.38.46.excalidraw]]

# 格式化字符串

> [!summary] 标准数字格式说明符

| 名称       | 字符 | 格式                                | 例子          |
| ---------- | ---- | ----------------------------------- | ------------- |
| 货币       | C,c  | {C/c{精度}(小数位数)}               | `{price:C5}`  |
| 数字       | D,d  | {D/d{精度}(补0位数)}，带负号        | `{number:d5`  |
| 浮点数     | F,f  | {F/f{精度}(小数位数)}，带负号       | `{number:f5`  |
| 十六进制   | X,x  | {X/x{精度}(补0位数)}，X/x代表大小写 | `{number:X3}` |
| 数字       | N,n  | {N/n{精度}(小数位数)}，会加入`,`    | `{number:N5}` |
| 百分比     | P,p  | {P/p{精度}(小数位数)}，默认两位     | `{number:p5}` |
| 科学计数法 | E,e  | {E/e{精度}(小数位数)}               | `{number:e5}`              |

> [!summary] 对齐格式说明符
> 一般格式为：`{{变量}, [+/-]{字符对其长度}: {格式说明符}}`
> > [!example]
> > `{number, -5:D3}`，对齐5位，负数表示左对齐，如果数字超过5位则无效。

> [!summary] 内插字符串转义
> - 以`@`加在字符串开头时，字符串内的字符不会进行转义。
> - 以`@$`开头的字符串如果要包含`{`，`}`，需要使用`{{`或`}}`。

> [!summary] 内插字符串使用三元运算符
> 由于`:`在内插里有特殊含义，因此需要放到括号里。
> > [!example]
> > `$"{(value < 0.5 ? "smaller than 0.5": "greater than 0.5")}"`

# 接口的显式定义

显式定义指的是实现接口时，在前面加上接口的名称：
```csharp
interface IA
{
	void Func();
}

class A : IA
{
	void IA.Func() {}
}
```

一旦使用这种方式定义，那么只能通过接口类型来调用这个方法，换言之如果你有一个A的实例，你必须要将它转型为IA，才能使用这个接口。

显式定义主要用来：
- 处理多接口的重名问题；
- 实现[[什么是面向对象#接口分离原则|接口分离]]，把不属于这个类的接口显式实现；


[^1]: 根是指：全局，静态，栈上的局部，参数变量，寄存器中的变量。
