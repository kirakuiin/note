---
tags:
  - interview
  - unity
---

# Unity UI中粒子特效渲染层级如何控制？

- 使用Sorting Layer，在Renderer组件中可以设置这个属性来控制渲染顺序。
- 使用RenderQueue，在Material中可以设置RenderQueue来控制渲染顺序。
- 如果粒子是在不同的相机中渲染的，那么优先渲染深度低的相机内容。

总体来说其优先级为：
1. 比较相机深度，越小越优先。
2. RenderQueue 2500以下。
	1. Sorting Layer，越小越优先。
	2. RenderQueue，越小越优先。
	3. 如果2.相等，则按由近到远排序。
3. RenderQueue 2500[^1]以上。
	1. Sorting Layer，越小越优先。
	2. RenderQueue，越小越优先。
	3. 如果2.相等，则按由远到近排序[^2]。

# UGUI的合批

首先明确一次Drawcall的概念，即准备数据，发送到GPU，然后通知它开始渲染。这是一个完整的Drawcall流程。而批处理指的就是将材质，贴图相同的模型合并到一起，共用一次Drawcall，这个过程叫做合批。

UGUI除了上述规则，还要满足一些额外的规则。
- 首先同一个一个Canvas下的UI才能进行合批。
- 每一个UI对象都会计算出一个深度，材质ID，纹理ID，层级位置的四元组，用这个进行排序后，相连的UI才会尝试进行合批。
- 同个Canvas下有任意一个对象变化，都会导致整个Canvas重新计算合批。（不包含子Canvas）

所以基于以上规则我们可以得出几个比较简单的优化方案：
- 动静分离。
- UI尽量采用相同的图集。
- 文本和UI相分离。

> [!hint]
> 每一个UGUI元素实际上也是一个网格，只不过是由程序自动生成出来的。

# Unity是如何执行生命周期函数

通过反射得到对象确定实现的生命周期函数指针并存储起来，然后在一个主循环中不断执行它们。

# 协程的实现方式

`StartCoroutine`接受一个`IEnumerator`对象作为参数，然后调用它的`MoveNext(), Current()`以获得这个协程下次启动的时机，比如：
- null：下一帧继续；
- EndOfFrame：帧末继续；

# timeScale会影响Update吗

不会，Update和LateUpdate还会正常调用，但是FixedUpdate会受这个值的影响，如果timeScale=0，那么FixedUpdate不会在被调用。

timeScale影响deltaTime，但不影响fixedDeltaTime。

# 模板测试

最常见的应用就是实现各种遮罩，比如说圆形头像框就是通过模板测试实现的。

它的原理是通过一个模板缓冲，记录所有像素的模板值，默认值为0。

渲染物体时，有以下值可以影响模板缓冲：
- 模板值：模板缓冲中已经存在的值。
- 参考值：在渲染该物体前，有程序设置的值。
- 比较函数：决定如何将两个值比较。
- 操作函数：定义通过或者不通过后对模板值的更新操作。

模板测试是一个不可编程，可以配置的管线。它发生在透明度测试之后，深度测试之前。

[^1]: 2500是不透明和透明的分界点，大于2500就是透明渲染队列了。
[^2]: 透明队列要先渲染近的，这一点同不透明队列是不一样的，不透明的先渲染近的可能就不需要渲染远的了。
