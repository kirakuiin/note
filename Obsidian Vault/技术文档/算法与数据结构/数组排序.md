---
tags:
  - reference
  - algorithm/sort
---
# 堆排序

时间复杂度：$O(nlog_{2}n)$
稳定性：不稳定[^1]

> [!summary] 原理
> 设：数组为`arr`，`n`为数组的长度。
> 最大堆是一种二叉树，它确保所有的父节点必定大于子节点，根据这个性质，我们可以将`arr`建为最大堆，然后进行排序。
> 1. 将堆的根结点`arr[0]`和`arr[n-1]`交换，此时最大元素`arr[0]`位于数组末尾。
> 2. 将`arr[0..n-1]`重新建为最大堆，将`n-1`减小1。
> 3. 重复1，2步直到`n == 1`。

 ```python
 def HEAP_SORT(arr):
 	n = arr.LENGTH
 	MAKE_HEAP(arr)
 	for i in n-1..0:
 		SWAP(arr[0], arr[i])
 		HEAPIFY(arr, 0, i)
 		
 def MAKE_HEAP(arr):
	n = arr.LENGTH
	for i in (n-1)/2..-1:
		HEAPIFY(arr, i, n)
 
 def HEAPIFY(arr, i, n):
 	largest_idx = i
 	l_idx, r_idx = LEFT_CHILD(i), RIGHT_CHILD(i)
 	if l_idx < n and arr[largest_idx] < arr[l_idx]:
 		largest_idx = l_idx
 	if r_idx < n and arr[largest_idx] < arr[r_idx]:
 		largest_idx = r_idx
 	if largest_idx != i:
 		SWAP(arr[largest_idx], arr[i])
 		HEAPIFY(arr, largest_idx, n)
 
 def LEFT_CHILD(i):
 	return i*2+1
 
 def RIGHT_CHILD(i):
 	return i*2+2
 ```

# 快速排序

时间复杂度：$O(nlog_{2}n)$
稳定性：不稳定[^1]

> [!summary] 原理
> 快速排序的原理非常容易理解，即选定数组`arr`中的一个元素，将所有小于它的放到它的前面，剩下的放到它的后面，然后在对以这个元素为中心划分出来的两个子数组不断进行这一过程即可。

```python
def QUICKSORT(arr, begin, end):
	if begin < end:
		pivot = PARTITION(arr, begin, end)
		QUICKSORT(arr, begin, pivot)
		QUICKSORT(arr, pivot+1, end)

def PARTITION(arr, begin, end)
	key = arr[end-1]
	i = begin
	for j in begin..end-1:
		if arr[j] < key:
			SWAP(arr, i, j)
			i += 1
	SWAP(arr, i, end-1)
	return i
```
# 归并排序

# 冒泡排序

# 插入排序

# 选择排序

[^1]: 不稳定指的是如果两个元素大小相等，排序后相对前后位置可能发生变化。