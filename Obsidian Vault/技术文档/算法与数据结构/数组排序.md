---
tags:
  - algorithm
  - reference
---

# 堆排序

> [!summary] 原理
> 设：数组为`arr`，`n`为数组的长度。
> 最大堆是一种二叉树，它确保所有的父节点必定大于子节点，根据这个性质，我们可以将`arr`建为最大堆，然后进行排序。
> 1. 将堆的根结点`arr[0]`和`arr[n-1]`交换，此时最大元素`arr[0]`位于数组末尾。
> 2. 将`arr[0..n-1]`重新建为最大堆，将`n-1`减小1。
> 3. 重复1，2步直到`n == 1`。

> [!example] 伪代码
> ```python
> def HEAP_SORT(arr):
> 	n = arr.LENGTH
> 	MAKE_HEAP(arr)
> 	for i in n-1..0:
> 		SWAP(arr[0], arr[i])
> 		HEAPIFY(arr, 0, i)
> 		
> def MAKE_HEAP(arr):
>	n = arr.LENGTH
>	for i in (n-1)/2..-1:
>		HEAPIFY(arr, i, n)
> 
> def HEAPIFY(arr, i, n):
> 	largest_idx = i
> 	l_idx, r_idx = LEFT_CHILD(i), RIGHT_CHILD(i)
> 	if l_idx < n and arr[largest_idx] < arr[l_idx]:
> 		largest_idx = l_idx
> 	if r_idx < n and arr[largest_idx] < arr[r_idx]:
> 		largest_idx = r_idx
> 	if largest_idx != i:
> 		SWAP(arr[largest_idx], arr[i])
> 		HEAPIFY(arr, largest_idx, n)
> 
> def LEFT_CHILD(i):
> 	return i*2+1
> 
> def RIGHT_CHILD(i):
> 	return i*2+2
> ```

# 快速排序

# 归并排序