---
tags:
  - reference
  - dataStructure/graph
special_tag: algorithm
---
下面的算法用来求解图中距离相关的问题。
# 单源最短路径算法

给定一个带权的有向[[图]] $G = (V, E)$，其中每条边的权是一个实数，请计算出给定一点到其他各个顶点的最短长度。

> [!summary] Bellman-Ford算法

```python
def BELLMAN-FORD(v, V, E):
	pass
```

> [!summary] Dijkstra算法
> 该算法依据的是最短路径的最优子结构性质，即到一点的最短路径的每一部分都是最短路径。
> - 从起点开始，每一步都选择最短距离。
> - 不断更新到各个顶点的最短距离。
> 
> 注意：这个算法无法处理负权图。

```python
def DIJKSTRA(v, V, E):
	// 存储未被处理的顶点。
	open = set(V)
	
	dist = dict{}
	for vert in V:
		dist[vert] = INF
	dist[v] = 0

	while not open.ISEMPTY:
		// 取出开放集合里的最短距离。
		vert = FIND_MIN(open, dist)
		d = dist[vert]

		for t in vert.ADJ:
			if t not in open:
				continue
			dist[t] = MIN(dist[t], d + E[vert][t])

		// 从这里移除即代表已经找到了这个节点的最短路径。
		open.REMOVE(vert)
	
	return dist
```

# 多源最短路径算法

给定一个带权的有向[[图]] $G = (V, E)$，其中每条边的权是一个实数，请计算出任意一点到其他各个顶点的最短长度。

> [!summary] Floyd算法
> 任意两点$i, j$之间的最短距离只有两种情况：
> - $i, j$之间的路径就是最短距离。
> - $i$通过若干路径到$k$，$k$通过若干路径到$j$的总和是最短距离。
> 
> 所以将每一个顶点$V$作为中间点进行*松弛*，依次更新任意两点之间的路径距离，到最后即可求出最短距离。

```python
def FLOYD(V, E):
	for k in V:
		for i in V:
			for j in V:
				E[i][j] = MIN(E[i][j], E[i][k] + E[k][j])
```
