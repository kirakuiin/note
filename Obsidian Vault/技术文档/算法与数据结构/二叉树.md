---
tags:
  - record
  - dataStructure/tree
---
二叉树是一种非线性数据结构，由祖先和后代之间的派生关系，体现了一分为二的分治逻辑。类似于链表，每个节点包含一个值字段以及指向两个字节点的指针字段。

![[binary_tree_definition.png]]
# 遍历的三种类型

- 前序遍历：先根节点，然后左子树，最后右子树。
- 中序遍历：先左子树，然后根节点，最后右子树。
- 后序遍历：先左子树，然后右子树，最后根节点。

它们主要的区别在于可以执行操作的时机不同，前序是进入就执行，后序是等子节点处理完了在执行（此时可以得到子树的返回值），而中序则是处理完左子树后再执行。
# 典型应用

树作为一种天生具有递归定义性质的结构，其大部分算法基本都会使用递归思想进行处理，即你只需要考虑当前局部需要做什么操作，后续的操作由递归完成。

1. 遍历类型的问题，配合外部变量遍历树即可求得结果。
   > [!example] 二叉树的深度
   > 先序遍历每个节点，并将当前深度加一传递给每个子节点的递归函数，并由一个外部变量一直更新最大值。遍历完毕之后即可得到最大深度。
2. 子问题类型，通过子问题推导出原问题的答案。
   > [!example] 二叉树总和
> 后序遍历每个节点，并在最后相加两个子问题答案，最后返回的结果就是二叉树的总和。
3. 构造类型问题，给你两个序列，根据序列还原出原来的二叉树。
   > [!example] 根据前序和中序构造二叉树
   > 简单来说就是根据前序先确定根结点位置，然后将当前根结点构造到树之中，然后以根节点为界将中序拆分为两部分，在根据中序每部分的数量拆分前序为两部分。这样一个问题就划分为了两个子问题，然后子问题重复此步骤即可。
# 代码模板

```python
def TRAVERSE(root):
	if root is NONE:
		return
	// 前序
	traverse(root.LEFT)
	// 中序
	traverse(root.RIGHT)
	// 后序
```

```python
def SUB_TREE(root):
	if root is None:
		return
	left_res = SUB_TREE(root.LEFT)
	right_res = SUB_TREE(root.RIGHT)
	// 对结果做处理
	return result
```