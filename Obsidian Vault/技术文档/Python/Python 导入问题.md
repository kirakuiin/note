---
tags:
  - reference
  - python
---
> [!note] 导入的基础知识
> 1. `import`的搜索路径存储在`sys.path`列表之中，在列表的前边搜索到指定模块之后不会继续搜索。
> 2. 模块对象存储在`sys.modules`字典中，其中键为模块的`__name__`，值为模块对象。
> 3. 模块的`__name__`变量是由模块被`import`的时候决定的。
> 4. 在没有明确指定包结构的情况下，Python 是根据`__name__`来决定一个模块在包中的结构。如果是`__main__`，则它本身是顶层模块，没有包结构；如果是A.B.C结构，那么顶层模块是A，在其内导入逻辑顺序基本上为：
> 	   - 绝对导入：一个模块只能导入自身的子模块或和它的顶层模块同级别的模块及其子模块(`import C.D`，`import A1.B`)
> 	   - 相对导入：一个模块必须有包结构且只能导入它的顶层模块内部的模块(`import ..B1`，`from .import C1`，`import C1`)
> 	   - 标准导入：直接导入`sys.path`内可以找到的模块(`import xxx`)

> [!note] 导入的一般规则
> 1. 禁止使用隐式相对导入，在python2.7中可以通过 `from __future__ import absolute_import` 来禁止隐式相对导入。
> 2. 使用绝对导入的时候使用相同的前缀，即都使用`import yy.xxx`的形式，要么都是用`import zz.yy.xxx`。
> 3. 父包如果在`sys.path`，那么子包就不应该在`sys.path`里面。
> 4. 包外对象导入包内模块时，也使用绝对导入形式，不要使用标准导入。

> [!hint] 导入同步问题
> `from xx import yy`导入的`yy`不会和原本模块的`xx.yy`同步变化，因为：
> - `from xx import yy`，导入本地的`yy`对象是`xx.yy`对象的引用，如果`xx.yy`变化会导致**重新绑定**，并不会影响本地的`yy`变量。如果想要共享同一个变量请使用`import xx`，`xx.yy` 这样的语法。
> - 如果`yy`是可变类型(比如`list`，`dict`)，使用append这类操作是可以共享变化的，一旦使用`=`这样的赋值语句则会导致本地`yy`的id改变，发生**重新绑定**。
>
> > [!warning] reload()
> > 某些时候`reload`函数无效也是因为这个原因导致的。

> [!hint] 相同模组重复导入问题
> 在不同文件使用相同的`import`语句导入一个模块，结果产生了多个模块对象。这一般是由于如下两个问题导致的：
>- 父包和子包同时加入了`sys.path`。
>- 两句导入语句里一个是标准导入，一个是隐式的相对导入，虽然语句一致，但产生模块名是不一致的。

> [!hint] pyc导致的变动无效
> 在某个时刻，你将你包A里的\__init\__.py文件删掉了，但是代码里其他地方依然可以使用`A.X`这种语法。这时因为**pyc**没删掉，把**pyc**文件删掉就不能了。

> [!hint] `lambda`导致的循环引用
> 当你在类方法里使用`lambda`函数或者内部函数创建一个闭包的时候，闭包对象内部会持有被引用对象的引用，如果你没有将lambda闭包对象保存起来，离开作用域lambda自然消失，如果你将其保存了起来，并且这个被引用对象是self，那么此时会产生**循环引用**.
> > [!example]
> > ```python
> > class Test(object):
> >     def __init__(self):
> >         # 这里已经产生了循环引用了，即便你用弱引用方法包装对象A，闭包还是会持有self的引用。
> >         self.B = lambda: self.Print
> >
> >     def __del__(self):
> >         print('Test is be deleted')
> >
> >     def Print(self):
> >         """输出自身"""
> >         print('Test')
> > ```