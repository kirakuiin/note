> [!question] C#闭包概念。
> 闭包指的是函数引用不在其内部定义的外部变量。C#中闭包会创建一个类对象来存储引用，因此会在堆上分配内存。

> [!question] C#中的unsafe是什么？
> 代表未经验证的上下文。在unsafe关键字内可以使用指针，创建内存块等平时无法使用的操作。

> [!question] 值类型和引用类型的区别？
> - 值类型基类是`System.ValueType`，存放在栈中，内部存储的是对象的值。
> - 引用类型基类是`System.Object`，存放在堆中由GC进行释放，其内部存放的是对象的引用，即地址。

> [!question] 什么情况下会触发装箱拆箱
> - 将值类型存放到`ArrayList`中会触发装箱。
> - 使用上一步中存放的对象会导致拆箱。

> [!question] 渲染管线流程简述
> 1. 准备数据，简单剔除不会被渲染的对象。
> 2. 设置渲染状态，比如着色器，顶点，材质等等。
> 3. 通知GPU进行渲染。
> 4. 顶点着色器阶段，将模型坐标转化为裁剪空间坐标，纹理坐标生成，蒙皮也在此步骤。
> 5. 裁剪不在裁剪空间内的模型，剔除背面。
> 6. 齐次除法，将空间变换到标准设备空间。
> 7. 光栅化，将表面映射到每个像素上。
> 8. 像素着色器阶段，输出像素的颜色和透明度。
> 9. 如果颜色是不透明的且深度小于缓冲中的深度则直接写入；如果颜色是透明的且深度小于缓冲则根据透明度混合后写入缓冲。

> [!question] Unity UI中粒子特效渲染层级如何控制？
> - 使用Sorting Layer，在Renderer组件中可以设置这个属性来控制渲染顺序。
> - 使用RenderQueue，在Material中可以设置RenderQueue来控制渲染顺序。
> - 如果粒子是在不同的相机中渲染的，那么优先渲染深度低的相机内容。
> 
> 总体来说其优先级为：
> 1. 比较相机深度，越小越优先。
> 2. RenderQueue 2500以下。
> 	1. Sorting Layer，越小越优先。
> 	2. RenderQueue，越小越优先。
> 	3. 如果2.相等，则按由近到远排序。
> 3. RenderQueue 2500[^1]以上。
> 	1. Sorting Layer，越小越优先。
> 	2. RenderQueue，越小越优先。
> 	3. 如果2.相等，则按由远到近排序[^2]。

> [!question] UGUI的合批
> 首先明确一次Drawcall的概念，即准备数据，发送到GPU，然后通知它开始渲染。这是一个完整的Drawcall流程。而批处理指的就是将材质，贴图相同的模型合并到一起，共用一次Drawcall，这个过程叫做合批。
> 
> UGUI除了上述规则，还要满足一些额外的规则。
> - 首先同一个一个Canvas下的UI才能进行合批。
> - 每一个UI对象都会计算出一个深度，材质ID，纹理ID，层级位置的四元组，用这个进行排序后，相连的UI才会尝试进行合批。
> - 同个Canvas下有任意一个对象变化，都会导致整个Canvas重新计算合批。（不包含子Canvas）
> 
> 所以基于以上规则我们可以得出几个比较简单的优化方案：
> - 动静分离。
> - UI尽量采用相同的图集。
> - 文本和UI相分离。
> 
> > [!hint]
> > 每一个UGUI元素实际上也是一个网格，只不过是由程序自动生成出来的。

> [!question] Unity是如何执行生命周期函数
> 通过反射得到对象确定实现的生命周期函数指针并存储起来，然后在一个主循环中不断执行它们。

> [!question] C# GC的流程是如何的？
> GC是基于代的，引用跟踪算法回收器。
> 引用跟踪算法是指：
> 1. 遍历对中某一代的对象，将其设置为不可达；
> 2. 从所有的根[^3]出发，将所有可达的对象设置为可达；
> 3. 将所有不可达的对象回收；
> 4. 压缩地址，将存活对象连续排列，期间会涉及到数据拷贝，引用更新；
> 
> 代是基于如下假设成立的：
> - 对象越新，生命周期越短；
> - 对象越老，生命周期越长；
> - 回收堆的一部分速度大于回收整个堆；
> 所以每经历过一次GC，每被回收的对象就会被放到下一世代，世代越老，回收频率越低。
> 
> GC会在以下情况下触发：
> - 空间不足。
> - 显式调用GC.Collect。

[^1]: 2500是不透明和透明的分界点，大于2500就是透明渲染队列了。
[^2]: 透明队列要先渲染近的，这一点同不透明队列是不一样的，不透明的先渲染近的可能就不需要渲染远的了。
[^3]: 根是指：全局，静态，栈上的局部，参数变量，寄存器中的变量。