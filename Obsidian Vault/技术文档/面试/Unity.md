> [!question] 渲染管线流程简述
> 1. 准备数据，简单剔除不会被渲染的对象。
> 2. 设置渲染状态，比如着色器，顶点，材质等等。
> 3. 通知GPU进行渲染。
> 4. 顶点着色器阶段，将模型坐标转化为裁剪空间坐标，纹理坐标生成，蒙皮也在此步骤。
> 5. 裁剪不在裁剪空间内的模型，剔除背面。
> 6. 齐次除法，将空间变换到标准设备空间。
> 7. 光栅化，将表面映射到每个像素上。
> 8. 像素着色器阶段，输出像素的颜色和透明度。
> 9. 如果颜色是不透明的且深度小于缓冲中的深度则直接写入；如果颜色是透明的且深度小于缓冲则根据透明度混合后写入缓冲。

> [!question] Unity UI中粒子特效渲染层级如何控制？
> - 使用Sorting Layer，在Renderer组件中可以设置这个属性来控制渲染顺序。
> - 使用RenderQueue，在Material中可以设置RenderQueue来控制渲染顺序。
> - 如果粒子是在不同的相机中渲染的，那么优先渲染深度低的相机内容。
> 
> 总体来说其优先级为：
> 1. 比较相机深度，越小越优先。
> 2. RenderQueue 2500以下。
> 	1. Sorting Layer，越小越优先。
> 	2. RenderQueue，越小越优先。
> 	3. 如果2.相等，则按由近到远排序。
> 3. RenderQueue 2500[^1]以上。
> 	1. Sorting Layer，越小越优先。
> 	2. RenderQueue，越小越优先。
> 	3. 如果2.相等，则按由远到近排序[^2]。

> [!question] UGUI的合批
> 首先明确一次Drawcall的概念，即准备数据，发送到GPU，然后通知它开始渲染。这是一个完整的Drawcall流程。而批处理指的就是将材质，贴图相同的模型合并到一起，共用一次Drawcall，这个过程叫做合批。
> 
> UGUI除了上述规则，还要满足一些额外的规则。
> - 首先同一个一个Canvas下的UI才能进行合批。
> - 每一个UI对象都会计算出一个深度，材质ID，纹理ID，层级位置的四元组，用这个进行排序后，相连的UI才会尝试进行合批。
> - 同个Canvas下有任意一个对象变化，都会导致整个Canvas重新计算合批。（不包含子Canvas）
> 
> 所以基于以上规则我们可以得出几个比较简单的优化方案：
> - 动静分离。
> - UI尽量采用相同的图集。
> - 文本和UI相分离。
> 
> > [!hint]
> > 每一个UGUI元素实际上也是一个网格，只不过是由程序自动生成出来的。

> [!question] Unity是如何执行生命周期函数
> 通过反射得到对象确定实现的生命周期函数指针并存储起来，然后在一个主循环中不断执行它们。

> [!question] 协程的实现方式
> `StartCoroutine`接受一个`IEnumerator`对象作为参数，然后调用它的`MoveNext(), Current()`以获得这个协程下次启动的时机，比如：
> - null：下一帧继续；
> - EndOfFrame：帧末继续；

[^1]: 2500是不透明和透明的分界点，大于2500就是透明渲染队列了。
[^2]: 透明队列要先渲染近的，这一点同不透明队列是不一样的，不透明的先渲染近的可能就不需要渲染远的了。
[^3]: 根是指：全局，静态，栈上的局部，参数变量，寄存器中的变量。