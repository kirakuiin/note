> [!question] c++编译过程
> 1. 预处理；
> 	1. 将所有的`#include`语句替换为头文件的内容；
> 	2. 将所有的宏替换为真正的内容；
> 	3. 根据条件编译决定真正需要编译的内容；
> 2. 编译，通过语法，词法，语义分析，优化之后将每个文件代码转化为汇编代码，即 **.s**文件；
> 3. 汇编，通过不同平台的汇编器将每个文件的汇编代码转为机器码，即生成可重定向的二进制文件 **.o**；此时还会生成符号表（存放函数名，变量名等等），但此时它们还没有分配有效的地址；
> 4. 链接；
> 	1. 将所有的 **.o** 文件的数据段，代码段等段进行合并，符号表也同时合并，并重新建立好映射关系；
> 	2. 分配虚拟地址，并将其与符号表中的符号一一对应起来，使其成为正确的地址；
> 	3. 链接依赖文件；
> 		- 静态链接，如果依赖的静态库（.a)，那么会把静态库当作一个 **.o**文件来处理，将其各种符号合并，最终生成一个可执行文件；
> 		- 动态链接，如果依赖的是动态库（.dll)，如果发现某个符号的定义在动态库中，那么会把符号以及动态库记录到可执行文件中，当程序开始运行时由操作系统来完成剩余的链接工作，将对动态库的调用重定向到动态库中的代码；

> [!question] 动态链接和静态链接的对比
> - 静态链接：
> 	- 优点：
> 		- 执行速度快；
> 		- 不会因为运行时环境缺少库导致无法运行；
> 	- 缺点：
> 		- 体积大；
> 		- 当依赖的库改变时必须重新编译；
> - 动态链接：
> 	- 优点：
> 		- 更加节省内存；
> 		- 只要接口不变，可以同程序源代码各自独立变化，完成了解耦；
> 	- 缺点：
> 		- 使用动态链接后程序不是完备的，如果环境内缺少动态库则无法执行；

> [!question] c++运行时程序内存结构
> 在内存中分为5个区域：
> ![[C++ 2024-08-16 12.29.43.excalidraw]]
> - 代码段：存放编译后的机械码；
> - 数据段：存放显式初始化的全局变量，静态变量，常量；
> - BSS段：存放未初始化的全局变量或静态变量，全部设置为0；
> - 堆段：动态分配内存区，由程序员手动控制；
> - 栈段：存放函数调用参数，局部变量，任务的上下文，这部分由操作系统管理；

> [!question] 多态是如何实现的？
> 每个具有虚函数的都包含一个虚表指针，它指向一个指针数组，指针数组内部指向了这个类的全部可调用的虚函数。类似于静态变量，一个类型共享同一个虚表，并且位于数据区。
> ![[C++ 2024-08-16 12.19.38.excalidraw]]
> 当B继承A后，B和A内部的虚表指针数组内容是一样的，当B覆写A的部分虚函数后，B的虚表指针数组会更新，用B的函数覆盖A的函数。
> 
> 当使用父类型的引用或指针指向子类型的对象，并且调用虚函数时，会直接查看当前对象的虚表内部对应的虚函数，而当前对象运行时类型是子类型，所以调用的就是子类型的虚方法，由此实现了多态。


