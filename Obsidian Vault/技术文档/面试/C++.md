#  c++编译过程

1. 预处理；
	 	1. 将所有的`#include`语句替换为头文件的内容；
	 	2. 将所有的宏替换为真正的内容；
	 	3. 根据条件编译决定真正需要编译的内容；
2. 编译，通过语法，词法，语义分析，优化之后将每个文件代码转化为汇编代码，即 **.s**文件；
3. 汇编，通过不同平台的汇编器将每个文件的汇编代码转为机器码，即生成可重定向的二进制文件 **.o**；此时还会生成符号表（存放函数名，变量名等等），但此时它们还没有分配有效的地址；
4. 链接；
	1. 将所有的 **.o** 文件的数据段，代码段等段进行合并，符号表也同时合并，并重新建立好映射关系；
	2. 分配虚拟地址，并将其与符号表中的符号一一对应起来，使其成为正确的地址；
	3. 链接依赖文件；
		- 静态链接，如果依赖的静态库（.a)，那么会把静态库当作一个 **.o**文件来处理，将其各种符号合并，最终生成一个可执行文件；
		- 动态链接，如果依赖的是动态库（.dll)，如果发现某个符号的定义在动态库中，那么会把符号以及动态库记录到可执行文件中，当程序开始运行时由操作系统来完成剩余的链接工作，将对动态库的调用重定向到动态库中的代码；

# 动态链接和静态链接的对比

- 静态链接：
	- 优点：
		- 执行速度快；
		- 不会因为运行时环境缺少库导致无法运行；
	- 缺点：
		- 体积大；
		- 当依赖的库改变时必须重新编译；
- 动态链接：
	- 优点：
		- 更加节省内存；
		- 只要接口不变，可以同程序源代码各自独立变化，完成了解耦；
	- 缺点：
		- 使用动态链接后程序不是完备的，如果环境内缺少动态库则无法执行；

#  c++运行时程序内存结构

在内存中分为5个区域：
![[C++ 2024-08-16 12.29.43.excalidraw]]
- 代码段：存放编译后的机械码；
- 数据段：存放显式初始化的全局变量，静态变量，常量；
- BSS段：存放未初始化的全局变量或静态变量，全部设置为0；
- 堆段：动态分配内存区，由程序员手动控制；
- 栈段：存放函数调用参数，局部变量，任务的上下文，这部分由操作系统管理；

#  多态是如何实现的？

每个具有虚函数的都包含一个虚表指针，它指向一个指针数组，指针数组内部指向了这个类的全部可调用的虚函数。类似于静态变量，一个类型共享同一个虚表，并且位于数据区。
![[C++ 2024-08-16 12.19.38.excalidraw]]
当B继承A后，B和A内部的虚表指针数组内容是一样的，当B覆写A的部分虚函数后，B的虚表指针数组会更新，用B的函数覆盖A的函数。

当使用父类型的引用或指针指向子类型的对象，并且调用虚函数时，会直接查看当前对象的虚表内部对应的虚函数，而当前对象运行时类型是子类型，所以调用的就是子类型的虚方法，由此实现了多态。

# 棱型继承的问题与解决方案

![[C++ 2024-08-16 17.30.21.excalidraw]]

主要导致的问题是：
- 冗余性：导致了空间浪费；
- 二义性：无法确定该访问B还是C的`a`；

解决的方案就是在导致问题的源头使用虚继承：
```cpp
class B : virtual public A {}
class C : virtual public A {}
class D : public B, public C {}
```

使用之后内存结构里会多出虚基表，用来存储子类数据的偏移。

# volatile的作用

告诉编译器对象的值可能会以未明确指示的方式法改变：
- 硬件寄存器；
- 中断服务程序；
- 多线程中主线程定义的变量；

一旦声明后，编译器不会对其进行优化，每次访问这个变量都会直接从内存中读取；

# 引用和指针的区别

引用指的是一个对象的别名，而指针实际上是一个变量，其内部存储了其他变量的地址。

它们的区别主要有以下几点：
- 引用初始化时就要赋值，而指针不用；
- 指针可以设置为空，但引用不能；
- 引用可以向变量那样直接使用，但指针不行，需要用`->`；

# 三种智能指针的功能

- **unique_ptr**：独占资源的指针，任何时候都是只有一个**unique_ptr**占有资源。它持有的资源只能转移或者被释放；
- **shared_ptr**：共享所有权的指针，即多个**shared_ptr**可以使用同一个对象，当最后一个被销毁时，释放持有的资源；
- **weak_ptr**：弱引用指针，它不会增加引用计数，主要用于防止循环引用；

> [!hint] shared_ptr的实现方式
> 本质上是一个代理，用来控制对对象的访问，其内部需要
> - 一个对象类型的指针，用来指向保存的对象；
> - 一个整形指针，用来保存引用计数，用指针来保存计数可以实现多个指针之间共享计数的功能；
> 
> 重载两个指针相关的操作符，然后在初始化，拷贝，赋值，析构等时刻维护对象和计数就可以了。

# extern "C"的作用

这句话代表着被这条语句包围的语句，都用C的方式来处理，而不是C++：
```c
// math.h
extern "C" 
{
int add(int a, int b);
int div(int a, int b);
}

// a cpp file

```

这种用法的主要用途是让C++代码可以调用C编写的文件，最主要的原因是c++由于支持重载，所以会对函数名进行名称粉碎的过程，比如一个`add`的函数如果使用c和c++的编译器，会生成不同的符号：

```C
// c++
add => __Z12add
// c
add => _add
```

当