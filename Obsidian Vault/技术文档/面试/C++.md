#  c++编译过程

1. 预处理；
	 	1. 将所有的`#include`语句替换为头文件的内容；
	 	2. 将所有的宏替换为真正的内容；
	 	3. 根据条件编译决定真正需要编译的内容；
2. 编译，通过语法，词法，语义分析，优化之后将每个文件代码转化为汇编代码，即 **.s**文件；
3. 汇编，通过不同平台的汇编器将每个文件的汇编代码转为机器码，即生成可重定向的二进制文件 **.o**；此时还会生成符号表（存放函数名，变量名等等），但此时它们还没有分配有效的地址；
4. 链接；
	1. 将所有的 **.o** 文件的数据段，代码段等段进行合并，符号表也同时合并，并重新建立好映射关系；
	2. 分配虚拟地址，并将其与符号表中的符号一一对应起来，使其成为正确的地址；
	3. 链接依赖文件；
		- 静态链接，如果依赖的静态库（.a)，那么会把静态库当作一个 **.o**文件来处理，将其各种符号合并，最终生成一个可执行文件；
		- 动态链接，如果依赖的是动态库（.dll)，如果发现某个符号的定义在动态库中，那么会把符号以及动态库记录到可执行文件中，当程序开始运行时由操作系统来完成剩余的链接工作，将对动态库的调用重定向到动态库中的代码；

# 动态链接和静态链接的对比

- 静态链接：
	- 优点：
		- 执行速度快；
		- 不会因为运行时环境缺少库导致无法运行；
	- 缺点：
		- 体积大；
		- 当依赖的库改变时必须重新编译；
- 动态链接：
	- 优点：
		- 更加节省内存；
		- 只要接口不变，可以同程序源代码各自独立变化，完成了解耦；
	- 缺点：
		- 使用动态链接后程序不是完备的，如果环境内缺少动态库则无法执行；

#  c++运行时程序内存结构

在内存中分为5个区域：
![[C++ 2024-08-16 12.29.43.excalidraw]]
- 代码段：存放编译后的机器码；
- 数据段：存放显式初始化的全局变量，静态变量，常量；
- BSS段：存放未初始化的全局变量或静态变量，全部设置为0；
- 堆段：动态分配内存区，由程序员手动控制；
- 栈段：存放函数调用参数，局部变量，任务的上下文，这部分由操作系统管理；

#  多态是如何实现的？

每个具有虚函数的都包含一个虚表指针，它指向一个指针数组，指针数组内部指向了这个类的全部可调用的虚函数。类似于静态变量，一个类型共享同一个虚表，并且位于数据区。
![[C++ 2024-08-16 12.19.38.excalidraw]]
当B继承A后，B和A内部的虚表指针数组内容是一样的，当B覆写A的部分虚函数后，B的虚表指针数组会更新，用B的函数覆盖A的函数。

当使用父类型的引用或指针指向子类型的对象，并且调用虚函数时，会直接查看当前对象的虚表内部对应的虚函数，而当前对象运行时类型是子类型，所以调用的就是子类型的虚方法，由此实现了多态。

# 棱型继承的问题与解决方案

![[C++ 2024-08-16 17.30.21.excalidraw]]

主要导致的问题是：
- 冗余性：导致了空间浪费；
- 二义性：无法确定该访问B还是C的`a`；

解决的方案就是在导致问题的源头使用虚继承：
```cpp
class B : virtual public A {}
class C : virtual public A {}
class D : public B, public C {}
```

使用之后内存结构里会多出虚基表，用来存储子类数据的偏移。

# volatile的作用

告诉编译器对象的值可能会以未明确指示的方式法改变：
- 硬件寄存器；
- 中断服务程序；
- 多线程中主线程定义的变量；

一旦声明后，编译器不会对其进行优化，每次访问这个变量都会直接从内存中读取；

# 引用和指针的区别

引用指的是一个对象的别名，而指针实际上是一个变量，其内部存储了其他变量的地址。

它们的区别主要有以下几点：
- 引用初始化时就要赋值，而指针不用；
- 指针可以设置为空，但引用不能；
- 引用可以向变量那样直接使用，但指针不行，需要用`->`；

# 三种智能指针的功能

- **unique_ptr**：独占资源的指针，任何时候都是只有一个**unique_ptr**占有资源。它持有的资源只能转移或者被释放；
- **shared_ptr**：共享所有权的指针，即多个**shared_ptr**可以使用同一个对象，当最后一个被销毁时，释放持有的资源；
- **weak_ptr**：弱引用指针，它不会增加引用计数，主要用于防止循环引用；

> [!hint] shared_ptr的实现方式
> 本质上是一个代理，用来控制对对象的访问，其内部需要
> - 一个对象类型的指针，用来指向保存的对象；
> - 一个整形指针，用来保存引用计数，用指针来保存计数可以实现多个指针之间共享计数的功能；
> 
> 重载两个指针相关的操作符，然后在初始化，拷贝，赋值，析构等时刻维护对象和计数就可以了。

# extern "C"的作用

这句话代表着被这条语句包围的语句，都用C的方式来处理，而不是C++：
```c
// math.h
#ifdef __cplusplus
extern "C" 
{
#endif
int add(int a, int b);
int div(int a, int b);
#ifdef __cplusplus
}

#endif
// a cpp file
#include "math.h"
```

这种用法的主要用途是让C++代码可以调用C编写的文件，最主要的原因是c++由于支持重载，所以会对函数名进行名称粉碎的过程，比如一个`add`的函数如果使用c和c++的编译器，会生成不同的符号：

```C
// c++
add => __Z12add
// c
add => _add
```

当用c++的模式去链接c编写的代码时，就会出现符号`__Z12add`未定义的错误。但只要加上`extern "C"`，符号就会被解析为`_add`，这样就可以正确链接了；

> [!hint]
> 一般来说这个要搭配`__cplusplus`宏一起使用，让这个文件可以在c和c++中都能工作。

# 右值引用的作用是什么

延长**右值**[^1]的生命周期，是只可以在多个对象之间传递，避免了临时对象的拷贝和析构，增加了效率。

# 野指针和悬挂指针

野指针指的是未初始化的指针；而悬挂指针指的是指向的对象被释放，但该指针依然指向被收回的内存地址。它俩的共同点是都指向一片无效的内存区域。

为了避免出现这两种指针，最好养成以下习惯：
- 初始化时给指针设置为`nullptr`。
- 释放之后及时将其改为`nullptr`。
- 使用智能指针。

# 句柄和指针的区别

- 指针：指向内存中一块地址；
- 句柄：指向系统中某个资源的位置，而这个位置又指向了真实的物理资源，所以句柄是指针的指针；

# 指针常量和常量指针

- 指针常量，它是个指针类型的常量，也就是说它本身的值是没法改变的，但是它指向的对象的值是可以改变的；
```cpp
int a;
int * const p;
// wrong
p = &a;
// right
*p = a;
```
- 常量指针，它是个指向常量的指针，它本身的值可以改变，但是它指向的对象的值不能改变；
```cpp
int a;
const int * p;
// right
p = &a;
// wrong
*p = a;
```

# RAII 是什么

这是c++的资源管理策略，即资源获取时就初始化，在对象析构的时候则将其释放。

在进入需要使用资源的地方定义资源对象，当离开作用域时资源就会被自动释放。智能指针也是通过这个策略来管理资源的。

# static 都有什么作用

- 修饰全局函数或者变量，将会把这个定义隐藏起来，其他源文件无法看见。
- 修饰函数内的局部变量，会延长变量的生存周期，变为永久存在。
- 类内的静态成员变量为所有的类实例共享且永久存在。并且只能在类外定义。
- 类内的静态函数只能使用类的静态变量，不能使用`this`指针。

> [!hint] 匿名命名空间
> 对于隐藏源文件内的变量和定义，更推荐使用匿名命名空间。
> ```cpp
> namespace
> {
> 	// 效果等于加上了static
> 	void Func() {}
> 	int a = 1;
> }
> ```

# map和unordered_map的底层是什么

map使用红黑树实现的，红黑树是一个非严格的自平衡二叉树。红黑树要满足如下性质：
- 每个节点不是黑的就是红的；
- 根节点是黑色的；
- 叶子结点是黑色的；
- 从根节点到所有叶子黑色节点数量相同；
- 红色节点的子节点是黑色的；

unordered_map底层使用哈希表实现的，采用链地址法来存储冲突的键。

![[C++ 2024-08-17 01.12.10.excalidraw]]

# 四种强制转换

```cpp

// static_cast
int a = 1;
double b = static_cast<double>(a);

// const_cast
const int a = 1;
const int* p = &a;
int* q = const_cast<int*>(p);

// reinterpret_cast
int *a = new int(1);
double *d = reinterpret_cast<double*>(a);

// dynamic_cast
class Base {virtual func() {}};
class Derived : public Base {};

Base* p = new Derived();
Derived* q = dynamic_cast<Derived*>(p);
```

## static_cast

- 用于基本数据类型的转换，比如int=>double；
- 将子类指针转为父类指针；
- 将空指针转换为目标类型的空指针；
- 将任何类型的表达式转为`void`类型；

## const_cast

用于去掉常量指针或者常量引用的的`const`修饰符，去除之后可以用来修改变量。不过这种行为很危险，不推荐使用。

## reinterpret_cast

- 改变指针或者引用的类型；
- 将指针转换为整形；
- 将整形转换为指针或引用类型；

## dynamic_cast

这是唯一一个在运行时进行的转换，需要进行类型检查。它主要用于：
- 用于将带有虚函数的类型的指针安全的向上转型，此时作用等于`static_cast`；
- 用于将带有虚函数的类型的指针安全的向下转型，如果失败会返回`nullptr`；

# new, delete, malloc, free的区别

- new：开辟一片地址，调用构造函数；
- malloc：仅分配地址，返回一个无类型的指针；
- delete：调用析构函数，释放占用内存；
- free：释放占用的内存；

[^1]: 临时值，等号右边的值，不可以取地址。